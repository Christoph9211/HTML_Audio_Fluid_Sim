<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Fluid Simulation Reacting to Sound</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" crossorigin href="./dist/output.css">
  </head>
<body>
  <div id="loadingIndicator" class="loading-indicator">
    <div class="bg-primary rounded-full w-16 h-16 pulse"></div>
    <p class="mt-4 text-lg">Initializing...</p>
  </div>

  <div id="audioIndicator" class="audio-indicator" style="display: none;">
    <div class="wave" id="wave1"></div>
    <div class="wave" id="wave2"></div>
    <div class="wave" id="wave3"></div>
    <i class="text-white text-2xl">üé§</i>
  </div>

  <button class="controls-toggle" id="controlsToggle">‚öôÔ∏è</button>
  
  <div class="controls-panel" id="controlsPanel">
    <div class="flex flex-wrap justify-between items-center w-full mb-2">
      <h2 class="text-lg font-semibold m-0">Fluid Simulation</h2>
      <span id="fpsCounter" class="text-sm opacity-70">FPS: --</span>
    </div>
    
    <div class="scenes flex flex-wrap gap-2 mb-2">
      <button class="button" onclick="setupScene(1)">Wind Tunnel</button>
      <button class="button" onclick="setupScene(3)">Hires Tunnel</button>
      <button class="button" onclick="setupScene(0)">Tank</button>
      <button class="button" onclick="setupScene(2)">Paint</button>
    </div>
    
    <div class="options flex flex-wrap items-center mb-2">
      <div class="toggle-wrapper">
        <input type="checkbox" id="streamButton" class="toggle-switch" title="Toggle Streamlines">
        <label for="streamButton" class="toggle-label"></label>
        <span class="ml-2">Streamlines</span>
      </div>
      
      <div class="toggle-wrapper">
        <input type="checkbox" id="velocityButton" class="toggle-switch" title="Toggle Velocities">
        <label for="velocityButton" class="toggle-label"></label>
        <span class="ml-2">Velocities</span>
      </div>
      
      <div class="toggle-wrapper">
        <input type="checkbox" id="pressureButton" class="toggle-switch" title="Toggle Pressure">
        <label for="pressureButton" class="toggle-label"></label>
        <span class="ml-2">Pressure</span>
      </div>
      
      <div class="toggle-wrapper">
        <input type="checkbox" id="smokeButton" class="toggle-switch" checked title="Toggle Smoke">
        <label for="smokeButton" class="toggle-label"></label>
        <span class="ml-2">Smoke</span>
      </div>
      
      <div class="toggle-wrapper">
        <input type="checkbox" id="overrelaxButton" class="toggle-switch" checked title="Toggle Overrelax">
        <label for="overrelaxButton" class="toggle-label"></label>
        <span class="ml-2">Overrelax</span>
      </div>
      <div class="toggle-wrapper">
        <input type="checkbox" id="vorticityButton" class="toggle-switch" title="Toggle Vorticity">
        <label for="vorticityButton" class="toggle-label"></label>
        <span class="ml-2">Vorticity</span>
      </div>
      <div class="toggle-wrapper">
        <input type="checkbox" id="eduModeButton" class="toggle-switch" title="Toggle Educational Mode">
        <label for="eduModeButton" class="toggle-label"></label>
        <span class="ml-2">Edu Mode</span>
      </div>
    </div>

    <div class="color-map-controls flex flex-wrap items-center mb-2">
      <span class="mr-2">Color Map:</span>
      <div class="flex flex-wrap gap-2">
        <div class="toggle-wrapper">
          <input title="Default" type="radio" id="colorMapDefault" name="colorMap" value="default" class="toggle-switch">
          <label for="colorMapDefault" class="toggle-label"></label>
          <span class="ml-2">Default</span>
        </div>
        <div class="toggle-wrapper">
          <input title="Thermal" type="radio" id="colorMapThermal" name="colorMap" value="thermal" class="toggle-switch">
          <label for="colorMapThermal" class="toggle-label"></label>
          <span class="ml-2">Thermal</span>
        </div>
        <div class="toggle-wrapper">
          <input title="Rainbow" type="radio" id="colorMapRainbow" name="colorMap" value="rainbow" class="toggle-switch">
          <label for="colorMapRainbow" class="toggle-label"></label>
          <span class="ml-2">Rainbow</span>
        </div>
        <div class="toggle-wrapper">
          <input title="Plasma" type="radio" id="colorMapPlasma" name="colorMap" value="plasma" class="toggle-switch" checked>
          <label for="colorMapPlasma" class="toggle-label"></label>
          <span class="ml-2">Plasma</span>
        </div>
      </div>
    </div>
    
    <div class="vortex-controls flex flex-wrap items-center">
      <div class="toggle-wrapper">
        <input type="checkbox" id="vortexButton" class="toggle-switch" checked title="Toggle Vortices">
        <label for="vortexButton" class="toggle-label"></label>
        <span class="ml-2">Vortices</span>
      </div>
      
      <div class="flex items-center">
        <input type="range" min="1" max="50" value="10" class="slider" id="vortexStrength">
        <label for="vortexStrength" class="ml-2">Strength</label>
      </div>
    </div>
    
    <div class="audio-controls mt-3" id="audioControlsSection">
      <div class="toggle-wrapper">
        <input type="checkbox" id="audioButton" class="toggle-switch" checked title="Toggle Audio Reactive">
        <label for="audioButton" class="toggle-label"></label>
        <span class="ml-2">Audio Reactive</span>
      </div>
      
      <div class="flex items-center mt-2">
        <input type="range" min="1" max="100" value="50" class="slider" id="audioSensitivity">
        <label for="audioSensitivity" class="ml-2">Sensitivity</label>
      </div>
    </div>
    
    <div class="audio-status mt-3">
      <div id="noAudioMessage">
        <p>Microphone access is not available in this environment.</p>
        <button class="button mt-2" id="micPermissionBtn">Request Microphone Access</button>
      </div>
    </div>
  </div>
  
  <canvas id="myCanvas"></canvas>
  
  <script>
    // DOM elements
    const canvas = document.getElementById("myCanvas");
    const c = canvas.getContext("2d", { alpha: false });
    const loadingIndicator = document.getElementById("loadingIndicator");
    const audioIndicator = document.getElementById("audioIndicator"); // Added for enabling display
    const wave1 = document.getElementById("wave1");
    const wave2 = document.getElementById("wave2");
    const wave3 = document.getElementById("wave3");
    const controlsToggle = document.getElementById("controlsToggle");
    const controlsPanel = document.getElementById("controlsPanel");
    const fpsCounter = document.getElementById("fpsCounter");
    const streamButton = document.getElementById("streamButton");
    const velocityButton = document.getElementById("velocityButton");
    const pressureButton = document.getElementById("pressureButton");
    const smokeButton = document.getElementById("smokeButton");
    const overrelaxButton = document.getElementById("overrelaxButton");
    const vorticityButton = document.getElementById("vorticityButton");
    const eduModeButton = document.getElementById("eduModeButton");
    const vortexButton = document.getElementById("vortexButton");
    const vortexStrengthSlider = document.getElementById("vortexStrength");
    const audioButton = document.getElementById("audioButton");
    const audioSensitivitySlider = document.getElementById("audioSensitivity");
    const audioControlsSection = document.getElementById("audioControlsSection");
    const noAudioMessage = document.getElementById("noAudioMessage");
    const micPermissionBtn = document.getElementById("micPermissionBtn");
    const MAX_PHYSICS_DT = 1.0 / 60.0; // Limit each physics step
    const CFL_NUMBER = 0.4; // CFL safety factor for timestep
    let lastFrameTime = 0;

    // Setup canvas and resize handling
    function setupCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      canvas.style.display = "block";
      canvas.style.touchAction = "none"; // Prevents scrolling on mobile
      
      const bgColor = getComputedStyle(document.body).backgroundColor || 'rgb(30,30,30)'; // Fallback bgColor
      c.fillStyle = bgColor;
      c.clearRect(0, 0, canvas.width, canvas.height);
      c.fillRect(0, 0, canvas.width, canvas.height);
    }
    
    // Resize canvas when window size changes - with debounce
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      window.isResizing = true;
      resizeTimeout = setTimeout(() => {
        setupCanvas();
        updateSimDimensions();
        setupScene(scene.sceneNr);
        const bgColor = getComputedStyle(document.body).backgroundColor || 'rgb(30,30,30)';
        c.fillStyle = bgColor;
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.fillRect(0, 0, canvas.width, canvas.height);
        window.isResizing = false;
      }, 150);
    });
    
    setupCanvas();
    canvas.focus();

    // Define simulation constants
    const U_FIELD = 0, V_FIELD = 1, S_FIELD = 2;
    let simHeight = 1.1;	
    let cScale = canvas.height / simHeight;
    let simWidth = canvas.width / cScale;
    
    function updateSimDimensions() {
      cScale = canvas.height / simHeight;
      simWidth = canvas.width / cScale;
    }
    
    function cX(x) { return x * cScale; }
    function cY(y) { return canvas.height - y * cScale; }
    
    // ----- Audio Input Setup using Web Audio API -----
    let audioContext, analyser, dataArray;
    let audioEnabled = false; // Default to false, will be set by checkbox
    let audioSensitivity = 0.5; // Default sensitivity
    let audioAvailable = false;
    let noiseLevel = 0.05; // Initial default noise floor, will be calibrated

    // --- New variables for sound smoothing ---
    let smoothedRMS = 0.0;
    const smoothingFactor = 0.5; // Adjust this: lower is smoother (e.g., 0.1), higher is more responsive (e.g., 0.5)
    
    /**
     * Checks if the Web Audio API is available in this browser
     */
    function checkAudioSupport() {
      return !!(window.AudioContext || window.webkitAudioContext) && 
             !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
    }
    
    /**
     * Initializes audio input using the Web Audio API.
     */
    function initAudio() {
      if (!checkAudioSupport()) {
        console.warn("Web Audio API is not supported in this browser");
        showAudioNotAvailable();
        return;
      }
      
      loadingIndicator.style.display = "flex"; // Use flex for centering
      
      try {
        navigator.mediaDevices.getUserMedia({ audio: true })
        .then(function(stream) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const source = audioContext.createMediaStreamSource(stream);
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 256; // Smaller FFT size for quicker response, less frequency detail
          analyser.smoothingTimeConstant = 0.1; // Minimal smoothing from analyser itself
          source.connect(analyser);
          dataArray = new Uint8Array(analyser.frequencyBinCount);
          
          audioAvailable = true;
          if (audioButton) audioEnabled = audioButton.checked; // Sync with button state

          loadingIndicator.style.display = "none";
          audioControlsSection.style.display = "block";
          noAudioMessage.style.display = "none"; 
          if (audioIndicator) audioIndicator.style.display = audioEnabled && audioAvailable ? 'flex' : 'none'; // Show indicator
          startAudioVisualization();
          
          calibrateNoise();
        })
        .catch(function(err) {
          console.error('Error accessing microphone: ', err);
          loadingIndicator.style.display = "none";
          showAudioNotAvailable();
        });
      } catch (error) {
        console.error('Error initializing audio:', error);
        loadingIndicator.style.display = "none";
        showAudioNotAvailable();
      }
    }
    
    /**
     * Shows UI for when audio is not available
     */
    function showAudioNotAvailable() {
      audioEnabled = false;
      audioAvailable = false;
      noAudioMessage.style.display = "block";
      audioControlsSection.style.display = "none";
      if (audioIndicator) audioIndicator.style.display = 'none'; // Hide indicator
    }
    
    /**
     * Calibrates the background noise level
     */
    function calibrateNoise() {
      if (!analyser || !audioAvailable) return;
      
      let samples = 0;
      let totalNoise = 0;
      const numSamplesToTake = 20; // Increased samples for better average
      const sampleInterval = 50; // ms

      console.log("Starting noise calibration...");
      
      const sampleNoise = () => {
        if (!analyser) return; // Guard if analyser becomes null
        analyser.getByteTimeDomainData(dataArray);
        let sum = 0;
        for (let i = 0; i < dataArray.length; i++) {
          const sample = dataArray[i] - 128;
          sum += sample * sample;
        }
        
        const rms = Math.sqrt(sum / dataArray.length);
        totalNoise += rms;
        samples++;
        
        if (samples < numSamplesToTake) {
          setTimeout(sampleNoise, sampleInterval);
        } else {
          noiseLevel = (totalNoise / samples) + 0.5; // Dynamic calibration with a small buffer (was 0.005, increased for less false positives)
          smoothedRMS = noiseLevel; // Initialize smoothedRMS to noiseLevel
          console.log(`Noise floor calibrated to: ${noiseLevel.toFixed(4)} after ${samples} samples.`);
        }
      };
      sampleNoise();
    }
    
    /**
     * Starts the audio visualization with animated waves.
     */
    function startAudioVisualization() {
      if (wave1 && wave2 && wave3) { // Ensure elements exist
        wave1.style.animation = "wave 2s infinite";
        wave2.style.animation = "wave 2s infinite 0.6s";
        wave3.style.animation = "wave 2s infinite 1.2s";
      }
    }

    /**
     * Returns a normalized sound level between 0 and 1 based on RMS of the time-domain data.
     * Applies sensitivity adjustment and smoothing.
     * @return {number} normalized sound level
     */
    function getSoundLevel() {
      if (!audioEnabled || !analyser || !dataArray || !audioAvailable) return 0; 
      
      analyser.getByteTimeDomainData(dataArray);
      let sum = 0;
      for (let i = 0; i < dataArray.length; i++) {
        const sample = dataArray[i] - 128; 
        sum += sample * sample;
      }
      const currentRMS = Math.sqrt(sum / dataArray.length);

      // Apply EMA smoothing to RMS
      smoothedRMS = (smoothingFactor * currentRMS) + ((1 - smoothingFactor) * smoothedRMS);
      
      const cleanSignal = Math.max(0, smoothedRMS - noiseLevel);
      
      // Normalize based on an expected max clean RMS (e.g., 50-70 for loud sounds).
      // This value might need tuning based on microphone and typical input levels.
      const maxExpectedCleanRMS = 70; 
      let normalizedLevel = Math.min(cleanSignal / maxExpectedCleanRMS, 1.0); 

      // Apply sensitivity using a power curve.
      // audioSensitivity is 0.01 to 1.0 from the slider.
      // Exponent: low sensitivity -> high power (makes normalizedLevel small unless it's very high)
      //           high sensitivity -> low power (amplifies normalizedLevel)
      const exponent = 1.0 / (audioSensitivity * 1.9 + 0.1); // (e.g., sens=0.01 -> exp~9; sens=1.0 -> exp=0.5)
      normalizedLevel = Math.pow(normalizedLevel, exponent);
      
      return Math.min(normalizedLevel, 1.0); // Ensure it's capped at 1.0
    }
    
    // ----- Fluid Simulation Code -----
    class Fluid {
      constructor(density, numX, numY, h) {
        this.density = density;
        this.numX = numX + 2; 
        this.numY = numY + 2;
        this.numCells = this.numX * this.numY;
        this.h = h;
        
        this.u = new Float32Array(this.numCells);
        this.v = new Float32Array(this.numCells);
        this.newU = new Float32Array(this.numCells);
        this.newV = new Float32Array(this.numCells);
        this.p = new Float32Array(this.numCells);
        this.s = new Float32Array(this.numCells); 
        this.m = new Float32Array(this.numCells); 
        this.newM = new Float32Array(this.numCells);
        this.vorticity = new Float32Array(this.numCells); 
        this.m.fill(0.0); // Initialize smoke to 0 (clear) by default
        
        this.n = this.numY; 
        this.h2 = this.h * 0.5; 
      }
      
      integrate(dt, gravity) {
        const n = this.n;
        for (let i = 1; i < this.numX - 1; i++) {
            for (let j = 1; j < this.numY - 1; j++) {
                const index = i * n + j;
                if (this.s[index] !== 0.0 && this.s[i * n + (j - 1)] !== 0.0) { // Check cell itself and cell below it
                    this.v[index] += gravity * dt;
                }
            }
        }
      }
      
      solveIncompressibility(numIters, dt) {
        const n = this.n;
        const cp = this.density * this.h / dt; 
        
        for (let iter = 0; iter < numIters; iter++) {
          for (let i = 1; i < this.numX-1; i++) { 
            for (let j = 1; j < this.numY-1; j++) {
              const index = i*n + j;
              if (this.s[index] === 0.0) continue; 
              
              const sx0 = this.s[(i-1)*n + j]; 
              const sx1 = this.s[(i+1)*n + j]; 
              const sy0 = this.s[i*n + j-1]; 
              const sy1 = this.s[i*n + j+1]; 
              const sSum = sx0 + sx1 + sy0 + sy1; 
              
              if (sSum === 0.0) continue; 
              
              const div = this.u[(i+1)*n + j] - this.u[index] + 
                          this.v[i*n + j+1] - this.v[index];   
              
              let pCorr = -div / sSum; 
              pCorr *= scene.overRelaxation; 
              
              this.p[index] += cp * pCorr; 
              
              this.u[index]           -= sx0 * pCorr; 
              this.u[(i+1)*n + j]   += sx1 * pCorr; 
              this.v[index]           -= sy0 * pCorr; 
              this.v[i*n + j+1]     += sy1 * pCorr; 
            }
          }
        }
      }
      
      extrapolate() {
        const n = this.n;
        for (let i = 0; i < this.numX; i++) {
          this.u[i*n + 0] = this.u[i*n + 1]; 
          this.u[i*n + this.numY-1] = this.u[i*n + this.numY-2]; 
        }
        for (let j = 0; j < this.numY; j++) {
          this.v[0*n + j] = this.v[1*n + j]; 
          this.v[(this.numX-1)*n + j] = this.v[(this.numX-2)*n + j]; 
        }
      }
      
      sampleField(x, y, field) {
        const n = this.n;
        const h = this.h;
        const h1 = 1.0 / h; 
        const h2 = this.h2; 
        
        x = Math.max(Math.min(x, this.numX * h), h);
        y = Math.max(Math.min(y, this.numY * h), h);
        
        let dx = 0, dy = 0; 
        let f_array; 
        
        switch (field) {
          case U_FIELD: f_array = this.u; dy = h2; break; 
          case V_FIELD: f_array = this.v; dx = h2; break; 
          case S_FIELD: f_array = this.m; dx = h2; dy = h2; break; 
          default: f_array = this.m; dx = h2; dy = h2; break; // Should not happen
        }
        
        const x0 = Math.min(Math.floor((x-dx)*h1), this.numX-2); // Ensure x0 and x1 are valid indices
        const tx = ((x-dx) - x0*h) * h1; 
        const x1 = Math.min(x0 + 1, this.numX-1); 
        
        const y0 = Math.min(Math.floor((y-dy)*h1), this.numY-2); // Ensure y0 and y1 are valid indices
        const ty = ((y-dy) - y0*h) * h1; 
        const y1 = Math.min(y0 + 1, this.numY-1); 
        
        const sx = 1.0 - tx;
        const sy = 1.0 - ty;
        
        return sx*sy * f_array[x0*n + y0] +
               tx*sy * f_array[x1*n + y0] +
               tx*ty * f_array[x1*n + y1] +
               sx*ty * f_array[x0*n + y1];
      }
      
      avgU(i, j) {
        const n = this.n;
        return (this.u[i*n + j-1] + this.u[i*n + j] +
                this.u[(i+1)*n + j-1] + this.u[(i+1)*n + j]) * 0.25;
      }
      
      avgV(i, j) {
        const n = this.n;
        return (this.v[(i-1)*n + j] + this.v[i*n + j] +
                this.v[(i-1)*n + j+1] + this.v[i*n + j+1]) * 0.25;
      }
      
      advectVel(dt) {
        this.newU.set(this.u); 
        this.newV.set(this.v);
        
        const n = this.n;
        const h = this.h, h2 = this.h2; 
        
        for (let i = 1; i < this.numX; i++) { 
          for (let j = 1; j < this.numY; j++) { 
            
            if (this.s[i*n + j] !== 0.0 && this.s[(i-1)*n + j] !== 0.0 && j < this.numY - 1) { 
              let x_pos = i * h; 
              let y_pos = j * h + h2; 
              
              let u_val = this.u[i*n + j];
              let v_val = this.avgV(i, j); 
              
              x_pos = x_pos - dt*u_val;
              y_pos = y_pos - dt*v_val;
              
              this.newU[i*n + j] = this.sampleField(x_pos, y_pos, U_FIELD);
            }
            
            if (this.s[i*n + j] !== 0.0 && this.s[i*n + j-1] !== 0.0 && i < this.numX - 1) { 
              let x_pos = i * h + h2; 
              let y_pos = j * h; 
              
              let u_val = this.avgU(i, j); 
              let v_val = this.v[i*n + j];
              
              x_pos = x_pos - dt*u_val;
              y_pos = y_pos - dt*v_val;
              
              this.newV[i*n + j] = this.sampleField(x_pos, y_pos, V_FIELD);
            }
          }
        }
        this.u.set(this.newU);
        this.v.set(this.newV);
      }
      
      advectSmoke(dt) {
        this.newM.set(this.m); 
        const n = this.n;
        const h = this.h, h2 = this.h2; 
        
        for (let i = 1; i < this.numX-1; i++) { 
          for (let j = 1; j < this.numY-1; j++) {
            const index = i*n + j;
            if (this.s[index] !== 0.0) { 
              const u_val = (this.u[index] + this.u[(i+1)*n + j]) * 0.5; 
              const v_val = (this.v[index] + this.v[i*n + j+1]) * 0.5; 
              
              let x_pos = i*h + h2 - dt*u_val;
              let y_pos = j*h + h2 - dt*v_val;
              
              this.newM[index] = this.sampleField(x_pos, y_pos, S_FIELD);
            }
          }
        }
        this.m.set(this.newM);
      }
      
      computeVorticity() {
        const n = this.n;
        const inv2h = 1.0 / (2.0 * this.h); 

        for (let i = 1; i < this.numX - 1; i++) { 
          for (let j = 1; j < this.numY - 1; j++) {
            const index = i * n + j;
            if (this.s[index] === 0.0) { 
              this.vorticity[index] = 0;
              continue;
            }
            const du_dy = (this.u[i * n + j + 1] - this.u[i * n + j - 1]) * inv2h; 
            const dv_dx = (this.v[(i + 1) * n + j] - this.v[(i - 1) * n + j]) * inv2h; 
            this.vorticity[index] = dv_dx - du_dy;
          }
        }
      }

      computeMaxVelocity() {
        let maxVel = 0;
        const n = this.n;
        for (let i = 1; i < this.numX - 1; i++) {
          for (let j = 1; j < this.numY - 1; j++) {
            if (this.s[i * n + j] !== 0.0) {
              const u = (this.u[i * n + j] + this.u[(i + 1) * n + j]) * 0.5;
              const v = (this.v[i * n + j] + this.v[i * n + j + 1]) * 0.5;
              const speed = Math.sqrt(u * u + v * v);
              if (speed > maxVel) maxVel = speed;
            }
          }
        }
        return maxVel;
      }

      simulate(dt, gravity, numIters) {
        this.integrate(dt, gravity);
        this.p.fill(0.0); 
        this.solveIncompressibility(numIters, dt);
        this.extrapolate(); 
        this.advectVel(dt); 
        this.advectSmoke(dt); 
        if (scene.showVorticity) { 
            this.computeVorticity();
        }
      }
    }
    
    // ----- Vortex System -----
    class VortexPoint {
      constructor(x, y, strength = 1.0) {
        this.x = x; 
        this.y = y; 
        this.strength = strength;
        this.originalX = x;
        this.originalY = y;
        this.angle = Math.random() * Math.PI * 2; 
        this.rotationSpeed = 0.01 + Math.random() * 0.02; 
        this.lastSoundLevel = 0;
      }
      
      update(soundLevel, dt) {
        this.angle += this.rotationSpeed * dt * 60; 
        
        const displacementFactor = 0.02 + soundLevel * 0.05; // More displacement with louder sound
        if (soundLevel > this.lastSoundLevel) {
          this.x += (Math.random() - 0.5) * displacementFactor; 
          this.y += (Math.random() - 0.5) * displacementFactor;
        } else {
          this.x += (this.originalX - this.x) * 0.01; 
          this.y += (this.originalY - this.y) * 0.01;
          this.x += Math.cos(this.angle) * 0.0005;
          this.y += Math.sin(this.angle) * 0.0005;
        }
        
        // Faster decay if current sound is low, slower if sound is high (keeps them agitated)
        this.lastSoundLevel = soundLevel * (0.5 + soundLevel * 0.4); 
        this.normalizePosition(); 
      }
      
      normalizePosition() {
        // Vortex positions are in simulation coordinates, ensure they stay within a margin
        const margin = this.h * 2; // Keep them a couple of cells from the boundary
        this.x = Math.max(margin, Math.min(simWidth - margin, this.x));
        this.y = Math.max(margin, Math.min(simHeight - margin, this.y));
      }
    }
    
    // ----- Visualization and Color Helpers -----
    const colorMaps = {
      default: function(val, minVal, maxVal) {
        val = Math.min(Math.max(val, minVal), maxVal - 0.0001); 
        const d = maxVal - minVal;
        val = d === 0.0 ? 0.5 : (val - minVal) / d; 
        const m = 0.25; 
        const num = Math.floor(val / m); 
        const s = (val - num * m) / m; 
        let r, g, b;
        switch(num) {
          case 0: r = 0.0; g = s; b = 1.0; break;     
          case 1: r = 0.0; g = 1.0; b = 1.0 - s; break; 
          case 2: r = s; g = 1.0; b = 0.0; break;     
          case 3: r = 1.0; g = 1.0 - s; b = 0.0; break; 
          default: r = 1.0; g = 0.0; b = 0.0; break; // Should not happen with clamping
        }
        return [Math.floor(255*r), Math.floor(255*g), Math.floor(255*b), 255];
      },
      thermal: function(val, minVal, maxVal) {
        val = Math.min(Math.max(val, minVal), maxVal - 0.0001);
        const d = maxVal - minVal;
        val = d === 0.0 ? 0.5 : (val - minVal) / d;
        let r, g, b;
        if (val < 0.5) { 
            r = 0; 
            g = val * 2; 
            b = 1.0 - (val*2);
        } else { 
            r = (val - 0.5) * 2;
            g = 1.0 - ((val-0.5)*2);
            b = 0;
        }
        return [Math.floor(255 * r), Math.floor(255 * g), Math.floor(255 * b), 255];
      },
      rainbow: function(val, minVal, maxVal) {
        val = Math.min(Math.max(val, minVal), maxVal - 0.0001);
        const d = maxVal - minVal;
        val = d === 0.0 ? 0.5 : (val - minVal) / d; 
        let r = 0.0, g = 0.0, b = 0.0;
        const h = val * 6.0; 
        const i = Math.floor(h);
        const f = h - i;
        switch (i % 6) {
            case 0: r = 1; g = f; b = 0; break;
            case 1: r = 1 - f; g = 1; b = 0; break;
            case 2: r = 0; g = 1; b = f; break;
            case 3: r = 0; g = 1 - f; b = 1; break;
            case 4: r = f; g = 0; b = 1; break;
            case 5: r = 1; g = 0; b = 1 - f; break;
        }
        return [Math.floor(255 * r), Math.floor(255 * g), Math.floor(255 * b), 255];
      },
      plasma: function(val, minVal, maxVal) {
        val = Math.min(Math.max(val, minVal), maxVal - 0.0001);
        const d = maxVal - minVal;
        val = d === 0.0 ? 0.5 : (val - minVal) / d;
        const colors = [ 
          [13, 8, 135], [94, 0, 168], [173, 1, 158], [239, 65, 98], [253, 150, 38], [240, 249, 33]
        ];
        const segments = colors.length - 1;
        const segment = Math.min(Math.floor(val * segments), segments - 1);
        const t = (val * segments) - segment; 
        const c1 = colors[segment];
        const c2 = colors[segment + 1];
        return [
          Math.floor(c1[0] + t * (c2[0] - c1[0])),
          Math.floor(c1[1] + t * (c2[1] - c1[1])),
          Math.floor(c1[2] + t * (c2[2] - c1[2])),
          255
        ];
      }
    };
    let currentColorMap = colorMaps.plasma;
    function getSciColor(val, minVal, maxVal) {
      return currentColorMap(val, minVal, maxVal);
    }
    
    // ----- Scene and Rendering -----
    const scene = {
      gravity: -9.81, dt: 1.0 / 60.0, numIters: 40, frameNr: 0, overRelaxation: 1.9,
      obstacleX: 0.0, obstacleY: 0.0, obstacleRadius: 0.1, paused: false, sceneNr: 2, // Default to paint scene
      showObstacle: false, showStreamlines: false, showVelocities: false, showPressure: false, 
      showSmoke: true, showVorticity: false, showEduMode: false, useVortices: true,
      vortexStrength: 10.0, fluid: null, vortexPoints: [],
    };
    
    function setupScene(sceneNr = 0) {
      scene.sceneNr = sceneNr;
      scene.obstacleRadius = 0.1;
      scene.overRelaxation = 1.9; 
      scene.dt = 1.0 / 60.0;
      scene.numIters = 40; 
      
      scene.showStreamlines = false; scene.showVelocities = false; scene.showPressure = false;
      scene.showSmoke = true; scene.showVorticity = false; scene.showEduMode = false;
      scene.gravity = 0.0; 

      let res = (window.innerWidth < 768) ? 40 : 60; // Simplified resolution adjustment
      
      const domainHeight = 1.0; 
      const domainWidth = domainHeight / simHeight * simWidth; 
      const h = domainHeight / res; 
      const numX = Math.floor(domainWidth / h);
      const numY = Math.floor(domainHeight / h);
      const density = 1000.0; 
      
      scene.fluid = new Fluid(density, numX, numY, h);
      const f = scene.fluid;
      const n = f.numY; 
      f.m.fill(0.0); // Clear smoke for all scenes initially
      
      if (sceneNr === 0) { // Tank
        for (let i = 0; i < f.numX; i++) {
          for (let j = 0; j < f.numY; j++) {
            f.s[i*n+j] = (i === 0 || i === f.numX-1 || j === 0) ? 0.0 : 1.0;
          }
        }
        for (let i = 0; i < f.numX; i++) {
            for (let j = 0; j < Math.floor(f.numY / 2) ; j++) {
                if (f.s[i*n+j] !== 0.0) f.m[i*n+j] = 1.0; // Fill with smoke
            }
        }
        scene.gravity = -9.81; scene.showPressure = true; currentColorMap = colorMaps.plasma;
      } 
      else if (sceneNr === 1 || sceneNr === 3) { // Wind Tunnel / Hires Tunnel
        const inVel = 2.0; 
        for (let i = 0; i < f.numX; i++) {
          for (let j = 0; j < f.numY; j++) {
            f.s[i*n+j] = (j === 0 || j === f.numY-1) ? 0.0 : 1.0; // Top/bottom walls
            if (i === 0) f.s[i*n+j] = 0.0; // Solid left wall for inlet
            
            if (i === 1 && j > 0 && j < f.numY -1) { 
                 f.u[i*n+j] = inVel;
                 // Inject smoke in a band at the inlet
                 if (j > f.numY * 0.2 && j < f.numY * 0.8) f.m[i*n+j] = 1.0; 
            }
          }
        }
        setObstacle(domainWidth * 0.3, domainHeight * 0.5, true); 
        scene.gravity = 0.0; 
        if (sceneNr === 3) { 
          scene.numIters = 50; scene.showPressure = true; currentColorMap = colorMaps.plasma;
        } else { 
          scene.showSmoke = true; currentColorMap = colorMaps.default;
        }
      } 
      else if (sceneNr === 2) { // Paint
        for (let i = 0; i < f.numX; i++) {
          for (let j = 0; j < f.numY; j++) { f.s[i*n+j] = 1.0; }
        }
        scene.gravity = 0.0; scene.showSmoke = true; scene.obstacleRadius = 0.05; 
        currentColorMap = colorMaps.plasma; 
      }
      
      initializeVortexPoints(); 
      
      streamButton.checked = scene.showStreamlines; velocityButton.checked = scene.showVelocities;
      pressureButton.checked = scene.showPressure; smokeButton.checked = scene.showSmoke;
      vorticityButton.checked = scene.showVorticity; eduModeButton.checked = scene.showEduMode;   
      overrelaxButton.checked = scene.overRelaxation > 1.0; vortexButton.checked = scene.useVortices;
      vortexStrengthSlider.value = scene.vortexStrength;
      for (const mapName in colorMaps) {
        if (colorMaps[mapName] === currentColorMap) {
            const radio = document.getElementById('colorMap' + mapName.charAt(0).toUpperCase() + mapName.slice(1));
            if (radio) radio.checked = true;
            break;
        }
      }
    }
    
    function initializeVortexPoints() {
      scene.vortexPoints = []; 
      if (!scene.fluid) return; // Guard against fluid not being initialized
      const numPoints = 5; 
      const centerX = simWidth * 0.5; // Centered vortex arrangement
      const centerY = simHeight * 0.5;
      const radius = Math.min(simWidth, simHeight) * 0.2; 

      for (let i = 0; i < numPoints; i++) {
        const angle = (i / numPoints) * 2 * Math.PI;
        const x = centerX + radius * Math.cos(angle);
        const y = centerY + radius * Math.sin(angle);
        scene.vortexPoints.push(new VortexPoint(x, y, 0.8 + Math.random()*0.4));
      }
    }
    
    function applyVortexForces(dt) {
      if (!scene.useVortices || !scene.fluid) return;
      
      const fluid = scene.fluid;
      const numY = fluid.numY; 
      const cellSize = fluid.h;
      const vortexStrengthFactor = scene.vortexStrength * 0.1; 
      const soundLevel = audioEnabled && audioAvailable ? getSoundLevel() : 0.05; // Low base activity if no sound

      for (const vortex of scene.vortexPoints) {
        vortex.h = fluid.h; // Pass cell size to vortex for normalization if needed
        vortex.update(soundLevel, dt); 
        
        for (let i = 1; i < fluid.numX - 1; i++) {
          for (let j = 1; j < fluid.numY - 1; j++) {
            const index = i * numY + j;
            if (fluid.s[index] === 0.0) continue; 
            
            const cellCenterX = (i + 0.5) * cellSize; 
            const cellCenterY = (j + 0.5) * cellSize; 
            const dx = cellCenterX - vortex.x; 
            const dy = cellCenterY - vortex.y; 
            const distanceSq = dx * dx + dy * dy; 
            const maxInfluenceRadius = cellSize * 12; // Increased influence radius
            const maxInfluenceRadiusSq = maxInfluenceRadius * maxInfluenceRadius; 

            if (distanceSq < maxInfluenceRadiusSq && distanceSq > 0.0001) { 
              const distance = Math.sqrt(distanceSq);
              
              const baseActivityForce = 0.05; // Reduced base activity
              const soundInfluenceForce = soundLevel * 1.5; // Stronger influence from sound
              const falloff = Math.max(0, 1.0 - distance / maxInfluenceRadius); // Smoother falloff

              const forceMagnitude = falloff * vortex.strength * vortexStrengthFactor * (baseActivityForce + soundInfluenceForce);
              
              const forceX = -dy * forceMagnitude / distance;
              const forceY =  dx * forceMagnitude / distance;
              
              // Simplified force application to cell center, then distributed by solver
              // More accurate would be to apply to staggered grid points directly
              fluid.u[i*numY + j]           += forceX * dt; 
              fluid.u[(i+1)*numY + j]       += forceX * dt; 
              fluid.v[i*numY + j]           += forceY * dt; 
              fluid.v[i*numY + j+1]         += forceY * dt; 
            }
          }
        }
      }
    }
    
    function setObstacle(x, y, resetVel) {
      let vx = 0.0, vy = 0.0; 
      if (!resetVel && scene.dt > 0) { 
        vx = (x - scene.obstacleX) / scene.dt;
        vy = (y - scene.obstacleY) / scene.dt;
      }
      
      scene.obstacleX = x;
      scene.obstacleY = y;
      const r = scene.obstacleRadius; 
      const f = scene.fluid;
      if (!f) return; 
      const n = f.numY; 
      
      // Reset relevant part of 's' field before setting new obstacle, if not in paint mode
      if (scene.sceneNr !== 2) {
          const clearRadius = r + f.h * 2; // Clear a slightly larger area
          const minIX = Math.max(1, Math.floor((x - clearRadius) / f.h));
          const maxIX = Math.min(f.numX - 2, Math.ceil((x + clearRadius) / f.h));
          const minIY = Math.max(1, Math.floor((y - clearRadius) / f.h));
          const maxIY = Math.min(f.numY - 2, Math.ceil((y + clearRadius) / f.h));

          for (let i = minIX; i <= maxIX; i++) {
              for (let j = minIY; j <= maxIY; j++) {
                  // Only reset if it's not a fixed boundary from scene setup
                  if (!( (f.s[i*n+j] === 0.0 && (i === 0 || i === f.numX-1 || j === 0 || j === f.numY-1) ) )) {
                     // This condition is tricky, for now, let's assume non-paint mode obstacle overrides scene boundaries temporarily
                     // f.s[i*n+j] = 1.0; // Make fluid before carving obstacle
                  }
              }
          }
      }


      for (let i = 1; i < f.numX-1; i++) { 
        for (let j = 1; j < f.numY-1; j++) {
          // In non-paint mode, ensure we don't override permanent scene boundaries
          if (scene.sceneNr !== 2 && (i === 0 || i === f.numX-1 || j === 0 || j === f.numY-1) && f.s[i*n+j] === 0.0) {
            // continue; // Skip fixed boundaries
          } else {
             f.s[i*n+j] = 1.0; // Default to fluid, then carve obstacle
          }


          const dx = (i+0.5)*f.h - x; 
          const dy = (j+0.5)*f.h - y; 
          
          if (dx*dx + dy*dy < r*r) {
            f.s[i*n+j] = 0.0; 
            
            if (scene.sceneNr === 2) { 
              f.m[i*n+j] = Math.min(1.0, f.m[i*n+j] + 0.8); // More intense paint
            } else { 
              f.m[i*n+j] = 1.0; 
            }
            f.u[i*n+j]     = vx; f.u[(i+1)*n+j] = vx;
            f.v[i*n+j]     = vy; f.v[i*n+j+1]   = vy;
          }
        }
      }
      scene.showObstacle = true;
    }
    
    function applySoundImpulse() {
      if (!audioEnabled || !scene.fluid || !audioAvailable) return; 

      const soundLevel = getSoundLevel(); 
      
      if (soundLevel > 0.05) { // Lowered threshold for more frequent reaction
        const fluid = scene.fluid;
        const centerX = Math.floor(fluid.numX / 2);
        const centerY = Math.floor(fluid.numY / 2);
        // Make strong sounds much stronger, and even weak sounds have some effect
        const impulseStrength = (soundLevel * 1.5 + Math.pow(soundLevel, 3) * 5.0); 
        
        const regionSize = Math.floor(2 + soundLevel * 3); // Larger region for louder sounds
        for (let i = -regionSize; i <= regionSize; i++) {
          for (let j = -regionSize; j <= regionSize; j++) {
            const currentX = centerX + i;
            const currentY = centerY + j;
            if (currentX > 0 && currentX < fluid.numX -1 && currentY > 0 && currentY < fluid.numY -1) {
                const index = currentX * fluid.numY + currentY;
                if (fluid.s[index] !== 0.0) { 
                    fluid.u[index] += impulseStrength * (Math.random() - 0.5) * 0.5; // Reduced base random impulse
                    fluid.v[index] += impulseStrength * (Math.random() - 0.5) * 0.5;
                
                    if (scene.sceneNr === 2 && soundLevel > 0.1) { 
                        fluid.m[index] = Math.min(fluid.m[index] + soundLevel * 0.3, 1.0); // More smoke in paint
                    }
                }
            }
          }
        }
      }
    }
    
    function draw() {
      if (window.isResizing || !scene.fluid) { 
        return;
      }
      
      const bgColor = getComputedStyle(document.body).backgroundColor || 'rgb(30,30,30)';
      c.clearRect(0, 0, canvas.width, canvas.height);
      c.fillStyle = bgColor;
      c.fillRect(0, 0, canvas.width, canvas.height);
      
      const f = scene.fluid;
      const n = f.numY; 
      const h = f.h;    
      
      let minP = 0, maxP = 0, minVort = 0, maxVort = 0;
      let firstFluidCellFound = false;
      for (let i = 0; i < f.numCells; i++) {
          if (f.s[i] !== 0.0) { 
              if (!firstFluidCellFound) {
                  minP = f.p[i]; maxP = f.p[i];
                  minVort = f.vorticity[i]; maxVort = f.vorticity[i];
                  firstFluidCellFound = true;
              } else {
                  minP = Math.min(minP, f.p[i]); maxP = Math.max(maxP, f.p[i]);
                  minVort = Math.min(minVort, f.vorticity[i]); maxVort = Math.max(maxVort, f.vorticity[i]);
              }
          }
      }
      if (!firstFluidCellFound) { 
          minP = 0; maxP = 1; minVort = -1; maxVort = 1; 
      }

      const width = canvas.width; const height = canvas.height;
      const id = c.createImageData(width, height); 
      const data = id.data; 
      
      const cellWidthPx = Math.ceil(cScale * h);  
      const cellHeightPx = Math.ceil(cScale * h); 
      
      for (let i = 0; i < f.numX; i++) {
        for (let j = 0; j < f.numY; j++) {
          const idx = i*n+j; 
          let cellColor = [128, 128, 128, 255]; 
          const smokeValue = f.m[idx]; 

          if (scene.showVorticity) {
            const vort = f.vorticity[idx];
            cellColor = getSciColor(vort, minVort, maxVort);
            if (scene.showSmoke) {
                const smokeFactor = 0.6; // Smoke has stronger effect on vorticity viz
                cellColor[0] = Math.max(0, cellColor[0] * (1 - smokeValue * smokeFactor) + 30 * smokeValue * smokeFactor);
                cellColor[1] = Math.max(0, cellColor[1] * (1 - smokeValue * smokeFactor) + 30 * smokeValue * smokeFactor);
                cellColor[2] = Math.max(0, cellColor[2] * (1 - smokeValue * smokeFactor) + 30 * smokeValue * smokeFactor);
            }
          } else if (scene.showPressure) {
            const pVal = f.p[idx];
            cellColor = getSciColor(pVal, minP, maxP);
            if (scene.showSmoke) {
              cellColor[0] = Math.max(0, cellColor[0] - 255 * smokeValue * 0.7);
              cellColor[1] = Math.max(0, cellColor[1] - 255 * smokeValue * 0.7);
              cellColor[2] = Math.max(0, cellColor[2] - 255 * smokeValue * 0.7);
            }
          } else if (scene.showSmoke) {
            cellColor = getSciColor(smokeValue, 0.0, 1.0); 
          } else {
            cellColor = f.s[idx] === 0.0 ? [0, 0, 0, 255] : [220, 220, 220, 255]; 
          }
          
          if (f.s[idx] === 0.0) {
            cellColor = [20, 20, 20, 255]; 
          }

          const xPx = Math.floor(cX(i * h));
          const yPx = Math.floor(cY((j+1) * h)); 
          
          for (let yi = 0; yi < cellHeightPx; yi++) {
            const currentY = yPx + yi;
            if (currentY < 0 || currentY >= height) continue; 
            const rowOffset = (currentY * width + xPx) * 4; 
            for (let xi = 0; xi < cellWidthPx; xi++) {
              const currentX = xPx + xi;
              if (currentX < 0 || currentX >= width) continue; 
              const pixelOffset = rowOffset + xi * 4;
              if (pixelOffset < data.length - 3) { 
                data[pixelOffset]     = cellColor[0]; data[pixelOffset + 1] = cellColor[1]; 
                data[pixelOffset + 2] = cellColor[2]; data[pixelOffset + 3] = cellColor[3]; 
              }
            }
          }
        }
      }
      c.putImageData(id, 0, 0); 
      
      if (scene.useVortices) {
        c.lineWidth = 1.5; // Thinner lines for vortices
        const soundLevel = audioEnabled && audioAvailable ? getSoundLevel() : 0.05;
        
        for (const vortex of scene.vortexPoints) {
          const x = cX(vortex.x); 
          const y = cY(vortex.y);
          const intensity = Math.min(0.1 + soundLevel * 2.5, 1.0); // More sensitive intensity
          const radius = 5 + soundLevel * 15; // Radius more reactive
          
          c.beginPath();
          c.arc(x, y, radius, 0, Math.PI * 2); 
          c.strokeStyle = `rgba(255, 220, 50, ${intensity * 0.7})`; // Goldish stroke
          c.fillStyle = `rgba(255, 180, 0, ${intensity * 0.2})`; // Softer fill
          c.fill();
          c.stroke();
        }
      }

      if (scene.showStreamlines) drawStreamlines();
      if (scene.showVelocities) drawVelocities(); 
      if (scene.showEduMode) drawEducationalOverlay();
    }
    
    function drawStreamlines() {
      const f = scene.fluid; if (!f) return;
      const h = f.h;
      c.strokeStyle = "rgba(100, 255, 100, 0.4)"; // Lighter green
      c.lineWidth = 0.8; // Thinner streamlines
      const seedSpacingX = Math.max(1, Math.floor(f.numX / 25)); 
      const seedSpacingY = Math.max(1, Math.floor(f.numY / 25));
      for (let i = 0; i < f.numX; i += seedSpacingX) {
        for (let j = 0; j < f.numY; j += seedSpacingY) {
          if (f.s[i*f.numY + j] !== 0.0) { 
            traceStreamline((i + 0.5) * h, (j + 0.5) * h, f, h);
          }
        }
      }
    }
    
    function traceStreamline(x, y, f, h) {
      const maxSteps = 70;    
      const stepSize = h * 0.35; 
      let currentX = x; let currentY = y;
      c.beginPath(); c.moveTo(cX(currentX), cY(currentY)); 
      for (let steps = 0; steps < maxSteps; steps++) {
        const u = f.sampleField(currentX, currentY, U_FIELD);
        const v = f.sampleField(currentX, currentY, V_FIELD);
        const speed = Math.sqrt(u*u + v*v);
        if (speed < 0.00001) break; 
        const dx = (u / speed) * stepSize; const dy = (v / speed) * stepSize;
        currentX += dx; currentY += dy;
        const gridX = Math.floor(currentX / h); const gridY = Math.floor(currentY / h);
        if (gridX <= 0 || gridX >= f.numX -1 || gridY <= 0 || gridY >= f.numY -1 || f.s[gridX*f.numY + gridY] === 0.0) {
            break;
        }
        c.lineTo(cX(currentX), cY(currentY));
      }
      c.stroke();
    }

    function drawVelocities() {
      const f = scene.fluid; if (!f) return;
      const n = f.numY; const h = f.h;
      c.strokeStyle = "rgba(80, 80, 255, 0.6)"; 
      c.lineWidth = 0.8;
      const velScale = 0.018 * cScale; 
      const maxArrowLengthPx = 12;  
      const skipFactor = Math.max(1, Math.floor(f.numX / 35)); 
      for (let i = 1; i < f.numX -1; i += skipFactor) {
        for (let j = 1; j < f.numY -1; j += skipFactor) {
          const index = i*n+j;
          if (f.s[index] === 0.0) continue; 
          const u_val = (f.u[index] + f.u[(i+1)*n+j]) * 0.5;
          const v_val = (f.v[index] + f.v[i*n+j+1]) * 0.5;
          const speed = Math.sqrt(u_val*u_val + v_val*v_val);
          if (speed > 0.005) { 
            const startX_canvas = cX((i+0.5)*h); const startY_canvas = cY((j+0.5)*h);
            let vx_canvas = u_val * velScale; let vy_canvas = -v_val * velScale; 
            const arrowLengthPx = Math.sqrt(vx_canvas*vx_canvas + vy_canvas*vy_canvas);
            if (arrowLengthPx > maxArrowLengthPx) {
              const reduction = maxArrowLengthPx / arrowLengthPx;
              vx_canvas *= reduction; vy_canvas *= reduction;
            }
            const endX_canvas = startX_canvas + vx_canvas; const endY_canvas = startY_canvas + vy_canvas;
            c.beginPath(); c.moveTo(startX_canvas, startY_canvas); c.lineTo(endX_canvas, endY_canvas);
            const headAngle = Math.PI/7; const headLength = Math.min(4, arrowLengthPx * 0.35);
            const angle = Math.atan2(vy_canvas, vx_canvas);
            c.lineTo(endX_canvas - headLength * Math.cos(angle - headAngle), endY_canvas - headLength * Math.sin(angle - headAngle));
            c.moveTo(endX_canvas, endY_canvas);
            c.lineTo(endX_canvas - headLength * Math.cos(angle + headAngle), endY_canvas - headLength * Math.sin(angle + headAngle));
            c.stroke();
          }
        }
      }
    }

    function drawFluidInfo() {
      const fluid = scene.fluid;
      if (!fluid || !scene.showFluidInfo) return;

      const cellSize = fluid.h;
      const canvasX = (x) => cX(x * cellSize);
      const canvasY = (y) => cY(y * cellSize);
      const skipCells = Math.max(1, Math.floor(fluid.numX / 12));

      for (let i = 0; i < fluid.numX; i += skipCells) {
        for (let j = 0; j < fluid.numY; j += skipCells) {
          const index = i * fluid.numY + j;
          if (fluid.s[index] === 0.0) continue;

          const x = canvasX(i + 0.5);
          const y = canvasY(j + 0.5);
          let text = "";
          if (scene.showPressure) text = `P:${fluid.p[index].toFixed(1)}`;
          else if (scene.showVorticity) text = `V:${fluid.vorticity[index].toFixed(1)}`;
          else if (scene.showVelocities) {
            const u = (fluid.u[index] + fluid.u[(i + 1) * fluid.numY + j]) * 0.5;
            const v = (fluid.v[index] + fluid.v[i * fluid.numY + j + 1]) * 0.5;
            text = `u:${u.toFixed(1)}\nv:${v.toFixed(1)}`;
          } else if (scene.showSmoke) text = `S:${fluid.m[index].toFixed(1)}`;

          if (text) {
            c.fillStyle = "rgba(255, 255, 255, 0.7)";
            const lines = text.split("\n");
            const textWidth = c.measureText(lines[0]).width;
            c.fillRect(x - textWidth / 2 - 2, y - 8 * lines.length, textWidth + 4, 10 * lines.length);
            c.fillStyle = "rgba(0, 0, 0, 0.95)";
            lines.forEach((line, lineIdx) => {
              c.fillText(line, x, y - (lines.length - 1 - lineIdx) * 10 + 6);
            });
          }
        }
      }
    }
    
    // ----- Performance Monitoring -----
    let lastTime = 0; let frameCount = 0; let fps = 0;
    const fpsUpdateInterval = 500; let lastFpsUpdate = 0;
    function updateFps(timestamp) {
      if (!lastTime) { lastTime = timestamp; lastFpsUpdate = timestamp; return; }
      frameCount++; const elapsedSinceLastUpdate = timestamp - lastFpsUpdate;
      if (elapsedSinceLastUpdate > fpsUpdateInterval) {
        fps = Math.round(frameCount * 1000 / elapsedSinceLastUpdate);
        if (fpsCounter) fpsCounter.textContent = `FPS: ${fps}`;
        frameCount = 0; lastFpsUpdate = timestamp;
      }
      lastTime = timestamp; 
    }
    
    // ----- Main Simulation Loop -----
    // const MAX_PHYSICS_DT = 1.0 / 60.0; // Limit each physics step
    // let lastFrameTime = 0;

    function stepSimulation(totalDeltaTime) {
      if (!scene.fluid) return;

      // Calculate a safe timestep once per frame rather than every sub-step
      const maxVel = scene.fluid.computeMaxVelocity();
      let physicsDeltaTime = MAX_PHYSICS_DT;
      if (maxVel > 0) {
        const cflDeltaTime = CFL_NUMBER * scene.fluid.h / maxVel;
        physicsDeltaTime = Math.min(physicsDeltaTime, cflDeltaTime);
      }

      let accumulatedTime = 0;
      while (accumulatedTime < totalDeltaTime) {
        const stepDeltaTime = Math.min(physicsDeltaTime, totalDeltaTime - accumulatedTime);

        if (!scene.paused) {
          if (scene.useVortices) applyVortexForces(stepDeltaTime);
          scene.fluid.simulate(stepDeltaTime, scene.gravity, scene.numIters);
          scene.frameNr++;
        }
        accumulatedTime += stepDeltaTime;
      }
    }
    function update(currentTime) {
      if (window.isResizing) {
        requestAnimationFrame(update);
        return;
      }

      if (lastFrameTime === undefined) {
        lastFrameTime = currentTime;
        requestAnimationFrame(update);
        return;
      }

      const deltaTime = (currentTime - lastFrameTime) / 1000.0; // Time since last visual frame in seconds
      lastFrameTime = currentTime;

      updateFps(currentTime);

      if (audioEnabled && audioAvailable) {
        applySoundImpulse();
      }

      stepSimulation(deltaTime);

      draw();
      requestAnimationFrame(update);
    }
    
    // ----- Interaction Handlers -----
    let mouseIsDown = false; let currentTouchId = null; 
    function startInteraction(clientX, clientY) {
      const bounds = canvas.getBoundingClientRect();
      const mx = clientX - bounds.left; const my = clientY - bounds.top;  
      mouseIsDown = true;
      const simX = mx / cScale; const simY = (canvas.height - my) / cScale; 
      if (scene.sceneNr !== 2) { 
          setObstacle(simX, simY, true); 
      } else { // For paint mode, setObstacle is called in dragInteraction
          setObstacle(simX, simY, true); // Initial dab for paint mode
      }
    }
    function dragInteraction(clientX, clientY) {
      if (mouseIsDown) {
        const bounds = canvas.getBoundingClientRect();
        const mx = clientX - bounds.left; const my = clientY - bounds.top;
        const simX = mx / cScale; const simY = (canvas.height - my) / cScale;
        setObstacle(simX, simY, false); 
      }
    }
    function endInteraction() { 
      mouseIsDown = false; currentTouchId = null;
      if (scene.sceneNr !== 2 && scene.showObstacle) { 
         // scene.showObstacle = false; // Optionally hide mouse-drawn obstacle
      }
    }
    canvas.addEventListener('mousedown', e => { e.preventDefault(); startInteraction(e.clientX, e.clientY); });
    canvas.addEventListener('mouseup', endInteraction);
    canvas.addEventListener('mousemove', e => { dragInteraction(e.clientX, e.clientY); });
    canvas.addEventListener('mouseleave', endInteraction);
    canvas.addEventListener('touchstart', e => { e.preventDefault(); if (currentTouchId === null && e.changedTouches.length > 0) { const touch = e.changedTouches[0]; currentTouchId = touch.identifier; startInteraction(touch.clientX, touch.clientY);}}, { passive: false });
    canvas.addEventListener('touchend', e => { e.preventDefault(); for (let i = 0; i < e.changedTouches.length; i++) { if (e.changedTouches[i].identifier === currentTouchId) { endInteraction(); break; }}}, { passive: false });
    canvas.addEventListener('touchmove', e => { e.preventDefault(); for (let i = 0; i < e.changedTouches.length; i++) { const touch = e.changedTouches[i]; if (touch.identifier === currentTouchId) { dragInteraction(touch.clientX, touch.clientY); break; }}}, { passive: false });
    canvas.addEventListener('touchcancel', endInteraction);
    document.addEventListener('keydown', e => { if (e.key.toLowerCase() === 'p') { scene.paused = !scene.paused; }});
    
    // UI Control Handlers
    streamButton.addEventListener('change', function() { scene.showStreamlines = this.checked; });
    velocityButton.addEventListener('change', function() { scene.showVelocities = this.checked; });
    pressureButton.addEventListener('change', function() { scene.showPressure = this.checked; });
    smokeButton.addEventListener('change', function() { scene.showSmoke = this.checked; });
    overrelaxButton.addEventListener('change', function() { scene.overRelaxation = this.checked ? 1.9 : 1.0; });
    vorticityButton.addEventListener('change', function() { scene.showVorticity = this.checked; });
    eduModeButton.addEventListener('change', function() { scene.showEduMode = this.checked; });
    vortexButton.addEventListener('change', function() { scene.useVortices = this.checked; });
    vortexStrengthSlider.addEventListener('input', function() { scene.vortexStrength = parseFloat(this.value); });
    if (audioButton) {
        audioButton.addEventListener('change', function() {
            audioEnabled = this.checked;
            if (audioEnabled && !audioAvailable) { initAudio(); }
            if (audioIndicator) audioIndicator.style.display = audioEnabled && audioAvailable ? 'flex' : 'none';
        });
    }
    audioSensitivitySlider.addEventListener('input', function() { audioSensitivity = parseFloat(this.value) / 100.0; });
    if(micPermissionBtn) micPermissionBtn.addEventListener('click', initAudio);
    if(controlsToggle) controlsToggle.addEventListener('click', function() {
      const isVisible = controlsPanel.style.display !== 'none';
      controlsPanel.style.display = isVisible ? 'none' : 'block';
      this.textContent = isVisible ? '‚öôÔ∏è' : '√ó'; 
    });
    document.querySelectorAll('input[name="colorMap"]').forEach(radio => {
      radio.addEventListener('change', function() { if (this.checked) currentColorMap = colorMaps[this.value]; });
    });
    
    function initializeSimulation() {
        setupCanvas(); 
        updateSimDimensions();
        // Set default audio enabled state from checkbox
        if (audioButton) audioEnabled = audioButton.checked;


        setupScene(2); // Default scene

        loadingIndicator.style.display = 'flex'; 

        setTimeout(() => { 
            try {
                if (checkAudioSupport() && audioEnabled) { // Only initAudio if checkbox is initially checked
                    initAudio(); 
                } else if (!checkAudioSupport()){
                    showAudioNotAvailable();
                } else { // Audio supported but not enabled by default
                    loadingIndicator.style.display = 'none'; // Hide loading if not attempting audio
                     if (audioIndicator) audioIndicator.style.display = 'none';
                }
            } catch (error) {
                console.error("Could not initialize audio:", error);
                showAudioNotAvailable();
            } finally {
                // This finally block might hide loading too soon if initAudio is async and takes time.
                // initAudio itself handles hiding loadingIndicator on success/failure.
                if(scene.fluid) { 
                    if (!audioAvailable && !audioEnabled) loadingIndicator.style.display = 'none'; // Ensure it's hidden if audio wasn't attempted
                    lastTimestamp = performance.now(); 
                    requestAnimationFrame(update);
                } else {
                    console.error("Fluid not initialized, cannot start animation loop.");
                    loadingIndicator.innerHTML = "<p>Error initializing simulation.</p>";
                }
            }
        }, 100); 
    }

    window.addEventListener('DOMContentLoaded', (event) => {
        initializeSimulation();
    });

  </script>
</body>
</html>
<!-- <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Fluid Simulation Reacting to Sound</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="./output.css" rel="stylesheet">
  </head>
<body>
  <div id="loadingIndicator" class="loading-indicator">
    <div class="bg-primary rounded-full w-16 h-16 pulse"></div>
    <p class="mt-4 text-lg">Initializing...</p>
  </div>

  <div id="audioIndicator" class="audio-indicator" style="display: none;">
    <div class="wave" id="wave1"></div>
    <div class="wave" id="wave2"></div>
    <div class="wave" id="wave3"></div>
    <i class="text-white text-2xl">üé§</i>
  </div>

  <button class="controls-toggle" id="controlsToggle">‚öôÔ∏è</button>
  
  <div class="controls-panel" id="controlsPanel">
    <div class="flex flex-wrap justify-between items-center w-full mb-2">
      <h2 class="text-lg font-semibold m-0">Fluid Simulation</h2>
      <span id="fpsCounter" class="text-sm opacity-70">FPS: --</span>
    </div>
    
    <div class="scenes flex flex-wrap gap-2 mb-2">
      <button class="button" onclick="setupScene(1)">Wind Tunnel</button>
      <button class="button" onclick="setupScene(3)">Hires Tunnel</button>
      <button class="button" onclick="setupScene(0)">Tank</button>
      <button class="button" onclick="setupScene(2)">Paint</button>
    </div>
    
    <div class="options flex flex-wrap items-center mb-2">
      <div class="toggle-wrapper">
        <input type="checkbox" id="streamButton" class="toggle-switch" title="Toggle Streamlines">
        <label for="streamButton" class="toggle-label"></label>
        <span class="ml-2">Streamlines</span>
      </div>
      
      <div class="toggle-wrapper">
        <input type="checkbox" id="velocityButton" class="toggle-switch" title="Toggle Velocities">
        <label for="velocityButton" class="toggle-label"></label>
        <span class="ml-2">Velocities</span>
      </div>
      
      <div class="toggle-wrapper">
        <input type="checkbox" id="pressureButton" class="toggle-switch" title="Toggle Pressure">
        <label for="pressureButton" class="toggle-label"></label>
        <span class="ml-2">Pressure</span>
      </div>
      
      <div class="toggle-wrapper">
        <input type="checkbox" id="smokeButton" class="toggle-switch" checked title="Toggle Smoke">
        <label for="smokeButton" class="toggle-label"></label>
        <span class="ml-2">Smoke</span>
      </div>
      
      <div class="toggle-wrapper">
        <input type="checkbox" id="overrelaxButton" class="toggle-switch" checked title="Toggle Overrelax">
        <label for="overrelaxButton" class="toggle-label"></label>
        <span class="ml-2">Overrelax</span>
      </div>
      <div class="toggle-wrapper">
        <input type="checkbox" id="vorticityButton" class="toggle-switch" title="Toggle Vorticity">
        <label for="vorticityButton" class="toggle-label"></label>
        <span class="ml-2">Vorticity</span>
      </div>
      <div class="toggle-wrapper">
        <input type="checkbox" id="eduModeButton" class="toggle-switch" title="Toggle Educational Mode">
        <label for="eduModeButton" class="toggle-label"></label>
        <span class="ml-2">Edu Mode</span>
      </div>
    </div>

    <div class="color-map-controls flex flex-wrap items-center mb-2">
      <span class="mr-2">Color Map:</span>
      <div class="flex flex-wrap gap-2">
        <div class="toggle-wrapper">
          <input title="Default" type="radio" id="colorMapDefault" name="colorMap" value="default" class="toggle-switch">
          <label for="colorMapDefault" class="toggle-label"></label>
          <span class="ml-2">Default</span>
        </div>
        <div class="toggle-wrapper">
          <input title="Thermal" type="radio" id="colorMapThermal" name="colorMap" value="thermal" class="toggle-switch">
          <label for="colorMapThermal" class="toggle-label"></label>
          <span class="ml-2">Thermal</span>
        </div>
        <div class="toggle-wrapper">
          <input title="Rainbow" type="radio" id="colorMapRainbow" name="colorMap" value="rainbow" class="toggle-switch">
          <label for="colorMapRainbow" class="toggle-label"></label>
          <span class="ml-2">Rainbow</span>
        </div>
        <div class="toggle-wrapper">
          <input title="Plasma" type="radio" id="colorMapPlasma" name="colorMap" value="plasma" class="toggle-switch" checked>
          <label for="colorMapPlasma" class="toggle-label"></label>
          <span class="ml-2">Plasma</span>
        </div>
      </div>
    </div>
    
    <div class="vortex-controls flex flex-wrap items-center">
      <div class="toggle-wrapper">
        <input type="checkbox" id="vortexButton" class="toggle-switch" checked title="Toggle Vortices">
        <label for="vortexButton" class="toggle-label"></label>
        <span class="ml-2">Vortices</span>
      </div>
      
      <div class="flex items-center">
        <input type="range" min="1" max="50" value="10" class="slider" id="vortexStrength">
        <label for="vortexStrength" class="ml-2">Strength</label>
      </div>
    </div>
    
    <div class="audio-controls mt-3" id="audioControlsSection">
      <div class="toggle-wrapper">
        <input type="checkbox" id="audioButton" class="toggle-switch" checked title="Toggle Audio Reactive">
        <label for="audioButton" class="toggle-label"></label>
        <span class="ml-2">Audio Reactive</span>
      </div>
      
      <div class="flex items-center mt-2">
        <input type="range" min="1" max="100" value="50" class="slider" id="audioSensitivity">
        <label for="audioSensitivity" class="ml-2">Sensitivity</label>
      </div>
    </div>
    
    <div class="audio-status mt-3">
      <div id="noAudioMessage">
        <p>Microphone access is not available in this environment.</p>
        <button class="button mt-2" id="micPermissionBtn">Request Microphone Access</button>
      </div>
    </div>
  </div>
  
  <canvas id="myCanvas"></canvas>
  
  <script>
    // DOM elements
    const canvas = document.getElementById("myCanvas");
    const c = canvas.getContext("2d", { alpha: false });
    const loadingIndicator = document.getElementById("loadingIndicator");
    const audioIndicator = document.getElementById("audioIndicator"); // Added for enabling display
    const wave1 = document.getElementById("wave1");
    const wave2 = document.getElementById("wave2");
    const wave3 = document.getElementById("wave3");
    const controlsToggle = document.getElementById("controlsToggle");
    const controlsPanel = document.getElementById("controlsPanel");
    const fpsCounter = document.getElementById("fpsCounter");
    const streamButton = document.getElementById("streamButton");
    const velocityButton = document.getElementById("velocityButton");
    const pressureButton = document.getElementById("pressureButton");
    const smokeButton = document.getElementById("smokeButton");
    const overrelaxButton = document.getElementById("overrelaxButton");
    const vorticityButton = document.getElementById("vorticityButton");
    const eduModeButton = document.getElementById("eduModeButton");
    const vortexButton = document.getElementById("vortexButton");
    const vortexStrengthSlider = document.getElementById("vortexStrength");
    const audioButton = document.getElementById("audioButton");
    const audioSensitivitySlider = document.getElementById("audioSensitivity");
    const audioControlsSection = document.getElementById("audioControlsSection");
    const noAudioMessage = document.getElementById("noAudioMessage");
    const micPermissionBtn = document.getElementById("micPermissionBtn");

    // Reusable ImageData for drawing to avoid per-frame allocations
    let imageData;
    
    // Setup canvas and resize handling
    function setupCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      canvas.style.display = "block";
      canvas.style.touchAction = "none"; // Prevents scrolling on mobile
      
      const bgColor = getComputedStyle(document.body).backgroundColor || 'rgb(30,30,30)'; // Fallback bgColor
      c.fillStyle = bgColor;
      c.clearRect(0, 0, canvas.width, canvas.height);
      c.fillRect(0, 0, canvas.width, canvas.height);

      // Re-create ImageData when canvas size changes
      imageData = c.createImageData(canvas.width, canvas.height);
    }
    
    // Resize canvas when window size changes - with debounce
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      window.isResizing = true;
      resizeTimeout = setTimeout(() => {
        setupCanvas();
        updateSimDimensions();
        setupScene(scene.sceneNr);
        const bgColor = getComputedStyle(document.body).backgroundColor || 'rgb(30,30,30)';
        c.fillStyle = bgColor;
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.fillRect(0, 0, canvas.width, canvas.height);
        window.isResizing = false;
      }, 150);
    });
    
    setupCanvas();
    canvas.focus();

    // Define simulation constants
    const U_FIELD = 0, V_FIELD = 1, S_FIELD = 2;
    let simHeight = 1.1;	
    let cScale = canvas.height / simHeight;
    let simWidth = canvas.width / cScale;
    
    function updateSimDimensions() {
      cScale = canvas.height / simHeight;
      simWidth = canvas.width / cScale;
    }
    
    function cX(x) { return x * cScale; }
    function cY(y) { return canvas.height - y * cScale; }
    
    // ----- Audio Input Setup using Web Audio API -----
    let audioContext, analyser, dataArray;
    let audioEnabled = false; // Default to false, will be set by checkbox
    let audioSensitivity = 0.5; // Default sensitivity
    let audioAvailable = false;
    let noiseLevel = 0.05; // Initial default noise floor, will be calibrated

    // --- New variables for sound smoothing ---
    let smoothedRMS = 0.0;
    const smoothingFactor = 0.5; // Adjust this: lower is smoother (e.g., 0.1), higher is more responsive (e.g., 0.5)
    
    /**
     * Checks if the Web Audio API is available in this browser
     */
    function checkAudioSupport() {
      return !!(window.AudioContext || window.webkitAudioContext) && 
             !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
    }
    
    /**
     * Initializes audio input using the Web Audio API.
     */
    function initAudio() {
      if (!checkAudioSupport()) {
        console.warn("Web Audio API is not supported in this browser");
        showAudioNotAvailable();
        return;
      }
      
      loadingIndicator.style.display = "flex"; // Use flex for centering
      
      try {
        navigator.mediaDevices.getUserMedia({ audio: true })
        .then(function(stream) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const source = audioContext.createMediaStreamSource(stream);
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 256; // Smaller FFT size for quicker response, less frequency detail
          analyser.smoothingTimeConstant = 0.1; // Minimal smoothing from analyser itself
          source.connect(analyser);
          dataArray = new Uint8Array(analyser.frequencyBinCount);
          
          audioAvailable = true;
          if (audioButton) audioEnabled = audioButton.checked; // Sync with button state

          loadingIndicator.style.display = "none";
          audioControlsSection.style.display = "block";
          noAudioMessage.style.display = "none"; 
          if (audioIndicator) audioIndicator.style.display = audioEnabled && audioAvailable ? 'flex' : 'none'; // Show indicator
          startAudioVisualization();
          
          calibrateNoise();
        })
        .catch(function(err) {
          console.error('Error accessing microphone: ', err);
          loadingIndicator.style.display = "none";
          showAudioNotAvailable();
        });
      } catch (error) {
        console.error('Error initializing audio:', error);
        loadingIndicator.style.display = "none";
        showAudioNotAvailable();
      }
    }
    
    /**
     * Shows UI for when audio is not available
     */
    function showAudioNotAvailable() {
      audioEnabled = false;
      audioAvailable = false;
      noAudioMessage.style.display = "block";
      audioControlsSection.style.display = "none";
      if (audioIndicator) audioIndicator.style.display = 'none'; // Hide indicator
    }
    
    /**
     * Calibrates the background noise level
     */
    function calibrateNoise() {
      if (!analyser || !audioAvailable) return;
      
      let samples = 0;
      let totalNoise = 0;
      const numSamplesToTake = 20; // Increased samples for better average
      const sampleInterval = 50; // ms

      console.log("Starting noise calibration...");
      
      const sampleNoise = () => {
        if (!analyser) return; // Guard if analyser becomes null
        analyser.getByteTimeDomainData(dataArray);
        let sum = 0;
        for (let i = 0; i < dataArray.length; i++) {
          const sample = dataArray[i] - 128;
          sum += sample * sample;
        }
        
        const rms = Math.sqrt(sum / dataArray.length);
        totalNoise += rms;
        samples++;
        
        if (samples < numSamplesToTake) {
          setTimeout(sampleNoise, sampleInterval);
        } else {
          noiseLevel = (totalNoise / samples) + 0.5; // Dynamic calibration with a small buffer (was 0.005, increased for less false positives)
          smoothedRMS = noiseLevel; // Initialize smoothedRMS to noiseLevel
          console.log(`Noise floor calibrated to: ${noiseLevel.toFixed(4)} after ${samples} samples.`);
        }
      };
      sampleNoise();
    }
    
    /**
     * Starts the audio visualization with animated waves.
     */
    function startAudioVisualization() {
      if (wave1 && wave2 && wave3) { // Ensure elements exist
        wave1.style.animation = "wave 2s infinite";
        wave2.style.animation = "wave 2s infinite 0.6s";
        wave3.style.animation = "wave 2s infinite 1.2s";
      }
    }

    /**
     * Returns a normalized sound level between 0 and 1 based on RMS of the time-domain data.
     * Applies sensitivity adjustment and smoothing.
     * @return {number} normalized sound level
     */
    function getSoundLevel() {
      if (!audioEnabled || !analyser || !dataArray || !audioAvailable) return 0; 
      
      analyser.getByteTimeDomainData(dataArray);
      let sum = 0;
      for (let i = 0; i < dataArray.length; i++) {
        const sample = dataArray[i] - 128; 
        sum += sample * sample;
      }
      const currentRMS = Math.sqrt(sum / dataArray.length);

      // Apply EMA smoothing to RMS
      smoothedRMS = (smoothingFactor * currentRMS) + ((1 - smoothingFactor) * smoothedRMS);
      
      const cleanSignal = Math.max(0, smoothedRMS - noiseLevel);
      
      // Normalize based on an expected max clean RMS (e.g., 50-70 for loud sounds).
      // This value might need tuning based on microphone and typical input levels.
      const maxExpectedCleanRMS = 70; 
      let normalizedLevel = Math.min(cleanSignal / maxExpectedCleanRMS, 1.0); 

      // Apply sensitivity using a power curve.
      // audioSensitivity is 0.01 to 1.0 from the slider.
      // Exponent: low sensitivity -> high power (makes normalizedLevel small unless it's very high)
      //           high sensitivity -> low power (amplifies normalizedLevel)
      const exponent = 1.0 / (audioSensitivity * 1.9 + 0.1); // (e.g., sens=0.01 -> exp~9; sens=1.0 -> exp=0.5)
      normalizedLevel = Math.pow(normalizedLevel, exponent);
      
      return Math.min(normalizedLevel, 1.0); // Ensure it's capped at 1.0
    }
    
    // ----- Fluid Simulation Code -----
    class Fluid {
      constructor(density, numX, numY, h) {
        this.density = density;
        this.numX = numX + 2; 
        this.numY = numY + 2;
        this.numCells = this.numX * this.numY;
        this.h = h;
        
        this.u = new Float32Array(this.numCells);
        this.v = new Float32Array(this.numCells);
        this.newU = new Float32Array(this.numCells);
        this.newV = new Float32Array(this.numCells);
        this.p = new Float32Array(this.numCells);
        this.s = new Float32Array(this.numCells); 
        this.m = new Float32Array(this.numCells); 
        this.newM = new Float32Array(this.numCells);
        this.vorticity = new Float32Array(this.numCells); 
        this.m.fill(0.0); // Initialize smoke to 0 (clear) by default
        
        this.n = this.numY; 
        this.h2 = this.h * 0.5;
      }

      computeMaxVelocity() {
        const n = this.n;
        let maxVel = 0.0;
        for (let i = 1; i < this.numX - 1; i++) {
          for (let j = 1; j < this.numY - 1; j++) {
            if (this.s[i*n + j] === 0.0) continue;
            const u = this.u[i*n + j];
            const v = this.v[i*n + j];
            const mag = Math.hypot(u, v);
            if (mag > maxVel) maxVel = mag;
          }
        }
        return maxVel;
      }
      
      integrate(dt, gravity) {
        const n = this.n;
        for (let i = 1; i < this.numX - 1; i++) {
            for (let j = 1; j < this.numY - 1; j++) {
                const index = i * n + j;
                if (this.s[index] !== 0.0 && this.s[i * n + (j - 1)] !== 0.0) { // Check cell itself and cell below it
                    this.v[index] += gravity * dt;
                }
            }
        }
      }
      
      solveIncompressibility(numIters, dt) {
        const n = this.n;
        const cp = this.density * this.h / dt; 
        
        for (let iter = 0; iter < numIters; iter++) {
          for (let i = 1; i < this.numX-1; i++) { 
            for (let j = 1; j < this.numY-1; j++) {
              const index = i*n + j;
              if (this.s[index] === 0.0) continue; 
              
              const sx0 = this.s[(i-1)*n + j]; 
              const sx1 = this.s[(i+1)*n + j]; 
              const sy0 = this.s[i*n + j-1]; 
              const sy1 = this.s[i*n + j+1]; 
              const sSum = sx0 + sx1 + sy0 + sy1; 
              
              if (sSum === 0.0) continue; 
              
              const div = this.u[(i+1)*n + j] - this.u[index] + 
                          this.v[i*n + j+1] - this.v[index];   
              
              let pCorr = -div / sSum; 
              pCorr *= scene.overRelaxation; 
              
              this.p[index] += cp * pCorr; 
              
              this.u[index]           -= sx0 * pCorr; 
              this.u[(i+1)*n + j]   += sx1 * pCorr; 
              this.v[index]           -= sy0 * pCorr; 
              this.v[i*n + j+1]     += sy1 * pCorr; 
            }
          }
        }
      }
      
      extrapolate() {
        const n = this.n;
        for (let i = 0; i < this.numX; i++) {
          this.u[i*n + 0] = this.u[i*n + 1]; 
          this.u[i*n + this.numY-1] = this.u[i*n + this.numY-2]; 
        }
        for (let j = 0; j < this.numY; j++) {
          this.v[0*n + j] = this.v[1*n + j]; 
          this.v[(this.numX-1)*n + j] = this.v[(this.numX-2)*n + j]; 
        }
      }
      
      sampleField(x, y, field) {
        const n = this.n;
        const h = this.h;
        const h1 = 1.0 / h; 
        const h2 = this.h2; 
        
        x = Math.max(Math.min(x, this.numX * h), h);
        y = Math.max(Math.min(y, this.numY * h), h);
        
        let dx = 0, dy = 0; 
        let f_array; 
        
        switch (field) {
          case U_FIELD: f_array = this.u; dy = h2; break; 
          case V_FIELD: f_array = this.v; dx = h2; break; 
          case S_FIELD: f_array = this.m; dx = h2; dy = h2; break; 
          default: f_array = this.m; dx = h2; dy = h2; break; // Should not happen
        }
        
        const x0 = Math.min(Math.floor((x-dx)*h1), this.numX-2); // Ensure x0 and x1 are valid indices
        const tx = ((x-dx) - x0*h) * h1; 
        const x1 = Math.min(x0 + 1, this.numX-1); 
        
        const y0 = Math.min(Math.floor((y-dy)*h1), this.numY-2); // Ensure y0 and y1 are valid indices
        const ty = ((y-dy) - y0*h) * h1; 
        const y1 = Math.min(y0 + 1, this.numY-1); 
        
        const sx = 1.0 - tx;
        const sy = 1.0 - ty;
        
        return sx*sy * f_array[x0*n + y0] +
               tx*sy * f_array[x1*n + y0] +
               tx*ty * f_array[x1*n + y1] +
               sx*ty * f_array[x0*n + y1];
      }
      
      avgU(i, j) {
        const n = this.n;
        return (this.u[i*n + j-1] + this.u[i*n + j] +
                this.u[(i+1)*n + j-1] + this.u[(i+1)*n + j]) * 0.25;
      }
      
      avgV(i, j) {
        const n = this.n;
        return (this.v[(i-1)*n + j] + this.v[i*n + j] +
                this.v[(i-1)*n + j+1] + this.v[i*n + j+1]) * 0.25;
      }
      
      advectVel(dt) {
        this.newU.set(this.u); 
        this.newV.set(this.v);
        
        const n = this.n;
        const h = this.h, h2 = this.h2; 
        
        for (let i = 1; i < this.numX; i++) { 
          for (let j = 1; j < this.numY; j++) { 
            
            if (this.s[i*n + j] !== 0.0 && this.s[(i-1)*n + j] !== 0.0 && j < this.numY - 1) { 
              let x_pos = i * h; 
              let y_pos = j * h + h2; 
              
              let u_val = this.u[i*n + j];
              let v_val = this.avgV(i, j); 
              
              x_pos = x_pos - dt*u_val;
              y_pos = y_pos - dt*v_val;
              
              this.newU[i*n + j] = this.sampleField(x_pos, y_pos, U_FIELD);
            }
            
            if (this.s[i*n + j] !== 0.0 && this.s[i*n + j-1] !== 0.0 && i < this.numX - 1) { 
              let x_pos = i * h + h2; 
              let y_pos = j * h; 
              
              let u_val = this.avgU(i, j); 
              let v_val = this.v[i*n + j];
              
              x_pos = x_pos - dt*u_val;
              y_pos = y_pos - dt*v_val;
              
              this.newV[i*n + j] = this.sampleField(x_pos, y_pos, V_FIELD);
            }
          }
        }
        this.u.set(this.newU);
        this.v.set(this.newV);
      }
      
      advectSmoke(dt) {
        this.newM.set(this.m); 
        const n = this.n;
        const h = this.h, h2 = this.h2; 
        
        for (let i = 1; i < this.numX-1; i++) { 
          for (let j = 1; j < this.numY-1; j++) {
            const index = i*n + j;
            if (this.s[index] !== 0.0) { 
              const u_val = (this.u[index] + this.u[(i+1)*n + j]) * 0.5; 
              const v_val = (this.v[index] + this.v[i*n + j+1]) * 0.5; 
              
              let x_pos = i*h + h2 - dt*u_val;
              let y_pos = j*h + h2 - dt*v_val;
              
              this.newM[index] = this.sampleField(x_pos, y_pos, S_FIELD);
            }
          }
        }
        this.m.set(this.newM);
      }
      
      computeVorticity() {
        const n = this.n;
        const inv2h = 1.0 / (2.0 * this.h); 

        for (let i = 1; i < this.numX - 1; i++) { 
          for (let j = 1; j < this.numY - 1; j++) {
            const index = i * n + j;
            if (this.s[index] === 0.0) { 
              this.vorticity[index] = 0;
              continue;
            }
            const du_dy = (this.u[i * n + j + 1] - this.u[i * n + j - 1]) * inv2h; 
            const dv_dx = (this.v[(i + 1) * n + j] - this.v[(i - 1) * n + j]) * inv2h; 
            this.vorticity[index] = dv_dx - du_dy;
          }
        }
      }

      simulate(dt, gravity, numIters) {
        this.integrate(dt, gravity);
        this.p.fill(0.0); 
        this.solveIncompressibility(numIters, dt);
        this.extrapolate(); 
        this.advectVel(dt); 
        this.advectSmoke(dt); 
        if (scene.showVorticity) { 
            this.computeVorticity();
        }
      }
    }
    
    // ----- Vortex System -----
    class VortexPoint {
      constructor(x, y, strength = 1.0) {
        this.x = x; 
        this.y = y; 
        this.strength = strength;
        this.originalX = x;
        this.originalY = y;
        this.angle = Math.random() * Math.PI * 2; 
        this.rotationSpeed = 0.01 + Math.random() * 0.02; 
        this.lastSoundLevel = 0;
      }
      
      update(soundLevel, dt) {
        this.angle += this.rotationSpeed * dt * 60; 
        
        const displacementFactor = 0.02 + soundLevel * 0.05; // More displacement with louder sound
        if (soundLevel > this.lastSoundLevel) {
          this.x += (Math.random() - 0.5) * displacementFactor; 
          this.y += (Math.random() - 0.5) * displacementFactor;
        } else {
          this.x += (this.originalX - this.x) * 0.01; 
          this.y += (this.originalY - this.y) * 0.01;
          this.x += Math.cos(this.angle) * 0.0005;
          this.y += Math.sin(this.angle) * 0.0005;
        }
        
        // Faster decay if current sound is low, slower if sound is high (keeps them agitated)
        this.lastSoundLevel = soundLevel * (0.5 + soundLevel * 0.4); 
        this.normalizePosition(); 
      }
      
      normalizePosition() {
        // Vortex positions are in simulation coordinates, ensure they stay within a margin
        const margin = this.h * 2; // Keep them a couple of cells from the boundary
        this.x = Math.max(margin, Math.min(simWidth - margin, this.x));
        this.y = Math.max(margin, Math.min(simHeight - margin, this.y));
      }
    }
    
    // ----- Visualization and Color Helpers -----
    const colorMaps = {
      default: function(val, minVal, maxVal) {
        val = Math.min(Math.max(val, minVal), maxVal - 0.0001); 
        const d = maxVal - minVal;
        val = d === 0.0 ? 0.5 : (val - minVal) / d; 
        const m = 0.25; 
        const num = Math.floor(val / m); 
        const s = (val - num * m) / m; 
        let r, g, b;
        switch(num) {
          case 0: r = 0.0; g = s; b = 1.0; break;     
          case 1: r = 0.0; g = 1.0; b = 1.0 - s; break; 
          case 2: r = s; g = 1.0; b = 0.0; break;     
          case 3: r = 1.0; g = 1.0 - s; b = 0.0; break; 
          default: r = 1.0; g = 0.0; b = 0.0; break; // Should not happen with clamping
        }
        return [Math.floor(255*r), Math.floor(255*g), Math.floor(255*b), 255];
      },
      thermal: function(val, minVal, maxVal) {
        val = Math.min(Math.max(val, minVal), maxVal - 0.0001);
        const d = maxVal - minVal;
        val = d === 0.0 ? 0.5 : (val - minVal) / d;
        let r, g, b;
        if (val < 0.5) { 
            r = 0; 
            g = val * 2; 
            b = 1.0 - (val*2);
        } else { 
            r = (val - 0.5) * 2;
            g = 1.0 - ((val-0.5)*2);
            b = 0;
        }
        return [Math.floor(255 * r), Math.floor(255 * g), Math.floor(255 * b), 255];
      },
      rainbow: function(val, minVal, maxVal) {
        val = Math.min(Math.max(val, minVal), maxVal - 0.0001);
        const d = maxVal - minVal;
        val = d === 0.0 ? 0.5 : (val - minVal) / d; 
        let r = 0.0, g = 0.0, b = 0.0;
        const h = val * 6.0; 
        const i = Math.floor(h);
        const f = h - i;
        switch (i % 6) {
            case 0: r = 1; g = f; b = 0; break;
            case 1: r = 1 - f; g = 1; b = 0; break;
            case 2: r = 0; g = 1; b = f; break;
            case 3: r = 0; g = 1 - f; b = 1; break;
            case 4: r = f; g = 0; b = 1; break;
            case 5: r = 1; g = 0; b = 1 - f; break;
        }
        return [Math.floor(255 * r), Math.floor(255 * g), Math.floor(255 * b), 255];
      },
      plasma: function(val, minVal, maxVal) {
        val = Math.min(Math.max(val, minVal), maxVal - 0.0001);
        const d = maxVal - minVal;
        val = d === 0.0 ? 0.5 : (val - minVal) / d;
        const colors = [ 
          [13, 8, 135], [94, 0, 168], [173, 1, 158], [239, 65, 98], [253, 150, 38], [240, 249, 33]
        ];
        const segments = colors.length - 1;
        const segment = Math.min(Math.floor(val * segments), segments - 1);
        const t = (val * segments) - segment; 
        const c1 = colors[segment];
        const c2 = colors[segment + 1];
        return [
          Math.floor(c1[0] + t * (c2[0] - c1[0])),
          Math.floor(c1[1] + t * (c2[1] - c1[1])),
          Math.floor(c1[2] + t * (c2[2] - c1[2])),
          255
        ];
      }
    };
    let currentColorMap = colorMaps.plasma;
    function getSciColor(val, minVal, maxVal) {
      return currentColorMap(val, minVal, maxVal);
    }
    
    // ----- Scene and Rendering -----
    const scene = {
      gravity: -9.81, dt: 1.0 / 60.0, numIters: 40, frameNr: 0, overRelaxation: 1.9,
      obstacleX: 0.0, obstacleY: 0.0, obstacleRadius: 0.1, paused: false, sceneNr: 2, // Default to paint scene
      showObstacle: false, showStreamlines: false, showVelocities: false, showPressure: false, 
      showSmoke: true, showVorticity: false, showEduMode: false, useVortices: true,
      vortexStrength: 10.0, fluid: null, vortexPoints: [],
    };
    
    function setupScene(sceneNr = 0) {
      scene.sceneNr = sceneNr;
      scene.obstacleRadius = 0.1;
      scene.overRelaxation = 1.9; 
      scene.dt = 1.0 / 60.0;
      scene.numIters = 40; 
      
      scene.showStreamlines = false; scene.showVelocities = false; scene.showPressure = false;
      scene.showSmoke = true; scene.showVorticity = false; scene.showEduMode = false;
      scene.gravity = 0.0; 

      let res = (window.innerWidth < 768) ? 60 : 100; // Simplified resolution adjustment
      
      const domainHeight = 1.0; 
      const domainWidth = domainHeight / simHeight * simWidth; 
      const h = domainHeight / res; 
      const numX = Math.floor(domainWidth / h);
      const numY = Math.floor(domainHeight / h);
      const density = 1000.0; 
      
      scene.fluid = new Fluid(density, numX, numY, h);
      const f = scene.fluid;
      const n = f.numY; 
      f.m.fill(0.0); // Clear smoke for all scenes initially
      
      if (sceneNr === 0) { // Tank
        for (let i = 0; i < f.numX; i++) {
          for (let j = 0; j < f.numY; j++) {
            f.s[i*n+j] = (i === 0 || i === f.numX-1 || j === 0) ? 0.0 : 1.0;
          }
        }
        for (let i = 0; i < f.numX; i++) {
            for (let j = 0; j < Math.floor(f.numY / 2) ; j++) {
                if (f.s[i*n+j] !== 0.0) f.m[i*n+j] = 1.0; // Fill with smoke
            }
        }
        scene.gravity = -9.81; scene.showPressure = true; currentColorMap = colorMaps.plasma;
      } 
      else if (sceneNr === 1 || sceneNr === 3) { // Wind Tunnel / Hires Tunnel
        const inVel = 2.0; 
        for (let i = 0; i < f.numX; i++) {
          for (let j = 0; j < f.numY; j++) {
            f.s[i*n+j] = (j === 0 || j === f.numY-1) ? 0.0 : 1.0; // Top/bottom walls
            if (i === 0) f.s[i*n+j] = 0.0; // Solid left wall for inlet
            
            if (i === 1 && j > 0 && j < f.numY -1) { 
                 f.u[i*n+j] = inVel;
                 // Inject smoke in a band at the inlet
                 if (j > f.numY * 0.2 && j < f.numY * 0.8) f.m[i*n+j] = 1.0; 
            }
          }
        }
        setObstacle(domainWidth * 0.3, domainHeight * 0.5, true); 
        scene.gravity = 0.0; 
        if (sceneNr === 3) { 
          scene.numIters = 50; scene.showPressure = true; currentColorMap = colorMaps.plasma;
        } else { 
          scene.showSmoke = true; currentColorMap = colorMaps.default;
        }
      } 
      else if (sceneNr === 2) { // Paint
        for (let i = 0; i < f.numX; i++) {
          for (let j = 0; j < f.numY; j++) { f.s[i*n+j] = 1.0; }
        }
        scene.gravity = 0.0; scene.showSmoke = true; scene.obstacleRadius = 0.05; 
        currentColorMap = colorMaps.plasma; 
      }
      
      initializeVortexPoints(); 
      
      streamButton.checked = scene.showStreamlines; velocityButton.checked = scene.showVelocities;
      pressureButton.checked = scene.showPressure; smokeButton.checked = scene.showSmoke;
      vorticityButton.checked = scene.showVorticity; eduModeButton.checked = scene.showEduMode;   
      overrelaxButton.checked = scene.overRelaxation > 1.0; vortexButton.checked = scene.useVortices;
      vortexStrengthSlider.value = scene.vortexStrength;
      for (const mapName in colorMaps) {
        if (colorMaps[mapName] === currentColorMap) {
            const radio = document.getElementById('colorMap' + mapName.charAt(0).toUpperCase() + mapName.slice(1));
            if (radio) radio.checked = true;
            break;
        }
      }
    }
    
    function initializeVortexPoints() {
      scene.vortexPoints = []; 
      if (!scene.fluid) return; // Guard against fluid not being initialized
      const numPoints = 5; 
      const centerX = simWidth * 0.5; // Centered vortex arrangement
      const centerY = simHeight * 0.5;
      const radius = Math.min(simWidth, simHeight) * 0.2; 

      for (let i = 0; i < numPoints; i++) {
        const angle = (i / numPoints) * 2 * Math.PI;
        const x = centerX + radius * Math.cos(angle);
        const y = centerY + radius * Math.sin(angle);
        scene.vortexPoints.push(new VortexPoint(x, y, 0.8 + Math.random()*0.4));
      }
    }
    
    function applyVortexForces(dt) {
      if (!scene.useVortices || !scene.fluid) return;
      
      const fluid = scene.fluid;
      const numY = fluid.numY; 
      const cellSize = fluid.h;
      const vortexStrengthFactor = scene.vortexStrength * 0.1; 
      const soundLevel = audioEnabled && audioAvailable ? getSoundLevel() : 0.05; // Low base activity if no sound

      for (const vortex of scene.vortexPoints) {
        vortex.h = fluid.h; // Pass cell size to vortex for normalization if needed
        vortex.update(soundLevel, dt); 
        
        for (let i = 1; i < fluid.numX - 1; i++) {
          for (let j = 1; j < fluid.numY - 1; j++) {
            const index = i * numY + j;
            if (fluid.s[index] === 0.0) continue; 
            
            const cellCenterX = (i + 0.5) * cellSize; 
            const cellCenterY = (j + 0.5) * cellSize; 
            const dx = cellCenterX - vortex.x; 
            const dy = cellCenterY - vortex.y; 
            const distanceSq = dx * dx + dy * dy; 
            const maxInfluenceRadius = cellSize * 12; // Increased influence radius
            const maxInfluenceRadiusSq = maxInfluenceRadius * maxInfluenceRadius; 

            if (distanceSq < maxInfluenceRadiusSq && distanceSq > 0.0001) { 
              const distance = Math.sqrt(distanceSq);
              
              const baseActivityForce = 0.05; // Reduced base activity
              const soundInfluenceForce = soundLevel * 1.5; // Stronger influence from sound
              const falloff = Math.max(0, 1.0 - distance / maxInfluenceRadius); // Smoother falloff

              const forceMagnitude = falloff * vortex.strength * vortexStrengthFactor * (baseActivityForce + soundInfluenceForce);
              
              const forceX = -dy * forceMagnitude / distance;
              const forceY =  dx * forceMagnitude / distance;
              
              // Simplified force application to cell center, then distributed by solver
              // More accurate would be to apply to staggered grid points directly
              fluid.u[i*numY + j]           += forceX * dt; 
              fluid.u[(i+1)*numY + j]       += forceX * dt; 
              fluid.v[i*numY + j]           += forceY * dt; 
              fluid.v[i*numY + j+1]         += forceY * dt; 
            }
          }
        }
      }
    }
    
    function setObstacle(x, y, resetVel) {
      let vx = 0.0, vy = 0.0; 
      if (!resetVel && scene.dt > 0) { 
        vx = (x - scene.obstacleX) / scene.dt;
        vy = (y - scene.obstacleY) / scene.dt;
      }
      
      scene.obstacleX = x;
      scene.obstacleY = y;
      const r = scene.obstacleRadius; 
      const f = scene.fluid;
      if (!f) return; 
      const n = f.numY; 
      
      // Reset relevant part of 's' field before setting new obstacle, if not in paint mode
      if (scene.sceneNr !== 2) {
          const clearRadius = r + f.h * 2; // Clear a slightly larger area
          const minIX = Math.max(1, Math.floor((x - clearRadius) / f.h));
          const maxIX = Math.min(f.numX - 2, Math.ceil((x + clearRadius) / f.h));
          const minIY = Math.max(1, Math.floor((y - clearRadius) / f.h));
          const maxIY = Math.min(f.numY - 2, Math.ceil((y + clearRadius) / f.h));

          for (let i = minIX; i <= maxIX; i++) {
              for (let j = minIY; j <= maxIY; j++) {
                  // Only reset if it's not a fixed boundary from scene setup
                  if (!( (f.s[i*n+j] === 0.0 && (i === 0 || i === f.numX-1 || j === 0 || j === f.numY-1) ) )) {
                     // This condition is tricky, for now, let's assume non-paint mode obstacle overrides scene boundaries temporarily
                     // f.s[i*n+j] = 1.0; // Make fluid before carving obstacle
                  }
              }
          }
      }


      for (let i = 1; i < f.numX-1; i++) { 
        for (let j = 1; j < f.numY-1; j++) {
          // In non-paint mode, ensure we don't override permanent scene boundaries
          if (scene.sceneNr !== 2 && (i === 0 || i === f.numX-1 || j === 0 || j === f.numY-1) && f.s[i*n+j] === 0.0) {
            // continue; // Skip fixed boundaries
          } else {
             f.s[i*n+j] = 1.0; // Default to fluid, then carve obstacle
          }


          const dx = (i+0.5)*f.h - x; 
          const dy = (j+0.5)*f.h - y; 
          
          if (dx*dx + dy*dy < r*r) {
            f.s[i*n+j] = 0.0; 
            
            if (scene.sceneNr === 2) { 
              f.m[i*n+j] = Math.min(1.0, f.m[i*n+j] + 0.8); // More intense paint
            } else { 
              f.m[i*n+j] = 1.0; 
            }
            f.u[i*n+j]     = vx; f.u[(i+1)*n+j] = vx;
            f.v[i*n+j]     = vy; f.v[i*n+j+1]   = vy;
          }
        }
      }
      scene.showObstacle = true;
    }
    
    function applySoundImpulse() {
      if (!audioEnabled || !scene.fluid || !audioAvailable) return; 

      const soundLevel = getSoundLevel(); 
      
      if (soundLevel > 0.05) { // Lowered threshold for more frequent reaction
        const fluid = scene.fluid;
        const centerX = Math.floor(fluid.numX / 2);
        const centerY = Math.floor(fluid.numY / 2);
        // Make strong sounds much stronger, and even weak sounds have some effect
        const impulseStrength = (soundLevel * 1.5 + Math.pow(soundLevel, 3) * 5.0); 
        
        const regionSize = Math.floor(2 + soundLevel * 3); // Larger region for louder sounds
        for (let i = -regionSize; i <= regionSize; i++) {
          for (let j = -regionSize; j <= regionSize; j++) {
            const currentX = centerX + i;
            const currentY = centerY + j;
            if (currentX > 0 && currentX < fluid.numX -1 && currentY > 0 && currentY < fluid.numY -1) {
                const index = currentX * fluid.numY + currentY;
                if (fluid.s[index] !== 0.0) { 
                    fluid.u[index] += impulseStrength * (Math.random() - 0.5) * 0.5; // Reduced base random impulse
                    fluid.v[index] += impulseStrength * (Math.random() - 0.5) * 0.5;
                
                    if (scene.sceneNr === 2 && soundLevel > 0.1) { 
                        fluid.m[index] = Math.min(fluid.m[index] + soundLevel * 0.3, 1.0); // More smoke in paint
                    }
                }
            }
          }
        }
      }
    }
    
    function draw() {
      if (window.isResizing || !scene.fluid) { 
        return;
      }
      
      const bgColor = getComputedStyle(document.body).backgroundColor || 'rgb(30,30,30)';
      c.clearRect(0, 0, canvas.width, canvas.height);
      c.fillStyle = bgColor;
      c.fillRect(0, 0, canvas.width, canvas.height);
      
      const f = scene.fluid;
      const n = f.numY; 
      const h = f.h;    
      
      let minP = 0, maxP = 0, minVort = 0, maxVort = 0;
      let firstFluidCellFound = false;
      for (let i = 0; i < f.numCells; i++) {
          if (f.s[i] !== 0.0) { 
              if (!firstFluidCellFound) {
                  minP = f.p[i]; maxP = f.p[i];
                  minVort = f.vorticity[i]; maxVort = f.vorticity[i];
                  firstFluidCellFound = true;
              } else {
                  minP = Math.min(minP, f.p[i]); maxP = Math.max(maxP, f.p[i]);
                  minVort = Math.min(minVort, f.vorticity[i]); maxVort = Math.max(maxVort, f.vorticity[i]);
              }
          }
      }
      if (!firstFluidCellFound) { 
          minP = 0; maxP = 1; minVort = -1; maxVort = 1; 
      }

      const width = canvas.width; const height = canvas.height;
      const id = imageData;
      const data = id.data;
      
      const cellWidthPx = Math.ceil(cScale * h);  
      const cellHeightPx = Math.ceil(cScale * h); 
      
      for (let i = 0; i < f.numX; i++) {
        for (let j = 0; j < f.numY; j++) {
          const idx = i*n+j; 
          let cellColor = [128, 128, 128, 255]; 
          const smokeValue = f.m[idx]; 

          if (scene.showVorticity) {
            const vort = f.vorticity[idx];
            cellColor = getSciColor(vort, minVort, maxVort);
            if (scene.showSmoke) {
                const smokeFactor = 0.6; // Smoke has stronger effect on vorticity viz
                cellColor[0] = Math.max(0, cellColor[0] * (1 - smokeValue * smokeFactor) + 30 * smokeValue * smokeFactor);
                cellColor[1] = Math.max(0, cellColor[1] * (1 - smokeValue * smokeFactor) + 30 * smokeValue * smokeFactor);
                cellColor[2] = Math.max(0, cellColor[2] * (1 - smokeValue * smokeFactor) + 30 * smokeValue * smokeFactor);
            }
          } else if (scene.showPressure) {
            const pVal = f.p[idx];
            cellColor = getSciColor(pVal, minP, maxP);
            if (scene.showSmoke) {
              cellColor[0] = Math.max(0, cellColor[0] - 255 * smokeValue * 0.7);
              cellColor[1] = Math.max(0, cellColor[1] - 255 * smokeValue * 0.7);
              cellColor[2] = Math.max(0, cellColor[2] - 255 * smokeValue * 0.7);
            }
          } else if (scene.showSmoke) {
            cellColor = getSciColor(smokeValue, 0.0, 1.0); 
          } else {
            cellColor = f.s[idx] === 0.0 ? [0, 0, 0, 255] : [220, 220, 220, 255]; 
          }
          
          if (f.s[idx] === 0.0) {
            cellColor = [20, 20, 20, 255]; 
          }

          const xPx = Math.floor(cX(i * h));
          const yPx = Math.floor(cY((j+1) * h)); 
          
          for (let yi = 0; yi < cellHeightPx; yi++) {
            const currentY = yPx + yi;
            if (currentY < 0 || currentY >= height) continue; 
            const rowOffset = (currentY * width + xPx) * 4; 
            for (let xi = 0; xi < cellWidthPx; xi++) {
              const currentX = xPx + xi;
              if (currentX < 0 || currentX >= width) continue; 
              const pixelOffset = rowOffset + xi * 4;
              if (pixelOffset < data.length - 3) { 
                data[pixelOffset]     = cellColor[0]; data[pixelOffset + 1] = cellColor[1]; 
                data[pixelOffset + 2] = cellColor[2]; data[pixelOffset + 3] = cellColor[3]; 
              }
            }
          }
        }
      }
      c.putImageData(id, 0, 0); 
      
      if (scene.useVortices) {
        c.lineWidth = 1.5; // Thinner lines for vortices
        const soundLevel = audioEnabled && audioAvailable ? getSoundLevel() : 0.05;
        
        for (const vortex of scene.vortexPoints) {
          const x = cX(vortex.x); 
          const y = cY(vortex.y);
          const intensity = Math.min(0.1 + soundLevel * 2.5, 1.0); // More sensitive intensity
          const radius = 5 + soundLevel * 15; // Radius more reactive
          
          c.beginPath();
          c.arc(x, y, radius, 0, Math.PI * 2); 
          c.strokeStyle = `rgba(255, 220, 50, ${intensity * 0.7})`; // Goldish stroke
          c.fillStyle = `rgba(255, 180, 0, ${intensity * 0.2})`; // Softer fill
          c.fill();
          c.stroke();
        }
      }

      if (scene.showStreamlines) drawStreamlines();
      if (scene.showVelocities) drawVelocities(); 
      if (scene.showEduMode) drawEducationalOverlay();
    }
    
    function drawStreamlines() {
      const f = scene.fluid; if (!f) return;
      const h = f.h;
      c.strokeStyle = "rgba(100, 255, 100, 0.4)"; // Lighter green
      c.lineWidth = 0.8; // Thinner streamlines
      const seedSpacingX = Math.max(1, Math.floor(f.numX / 25)); 
      const seedSpacingY = Math.max(1, Math.floor(f.numY / 25));
      for (let i = 0; i < f.numX; i += seedSpacingX) {
        for (let j = 0; j < f.numY; j += seedSpacingY) {
          if (f.s[i*f.numY + j] !== 0.0) { 
            traceStreamline((i + 0.5) * h, (j + 0.5) * h, f, h);
          }
        }
      }
    }
    
    function traceStreamline(x, y, f, h) {
      const maxSteps = 70;    
      const stepSize = h * 0.35; 
      let currentX = x; let currentY = y;
      c.beginPath(); c.moveTo(cX(currentX), cY(currentY)); 
      for (let steps = 0; steps < maxSteps; steps++) {
        const u = f.sampleField(currentX, currentY, U_FIELD);
        const v = f.sampleField(currentX, currentY, V_FIELD);
        const speed = Math.sqrt(u*u + v*v);
        if (speed < 0.00001) break; 
        const dx = (u / speed) * stepSize; const dy = (v / speed) * stepSize;
        currentX += dx; currentY += dy;
        const gridX = Math.floor(currentX / h); const gridY = Math.floor(currentY / h);
        if (gridX <= 0 || gridX >= f.numX -1 || gridY <= 0 || gridY >= f.numY -1 || f.s[gridX*f.numY + gridY] === 0.0) {
            break;
        }
        c.lineTo(cX(currentX), cY(currentY));
      }
      c.stroke();
    }

    function drawVelocities() {
      const f = scene.fluid; if (!f) return;
      const n = f.numY; const h = f.h;
      c.strokeStyle = "rgba(80, 80, 255, 0.6)"; 
      c.lineWidth = 0.8;
      const velScale = 0.018 * cScale; 
      const maxArrowLengthPx = 12;  
      const skipFactor = Math.max(1, Math.floor(f.numX / 35)); 
      for (let i = 1; i < f.numX -1; i += skipFactor) {
        for (let j = 1; j < f.numY -1; j += skipFactor) {
          const index = i*n+j;
          if (f.s[index] === 0.0) continue; 
          const u_val = (f.u[index] + f.u[(i+1)*n+j]) * 0.5;
          const v_val = (f.v[index] + f.v[i*n+j+1]) * 0.5;
          const speed = Math.sqrt(u_val*u_val + v_val*v_val);
          if (speed > 0.005) { 
            const startX_canvas = cX((i+0.5)*h); const startY_canvas = cY((j+0.5)*h);
            let vx_canvas = u_val * velScale; let vy_canvas = -v_val * velScale; 
            const arrowLengthPx = Math.sqrt(vx_canvas*vx_canvas + vy_canvas*vy_canvas);
            if (arrowLengthPx > maxArrowLengthPx) {
              const reduction = maxArrowLengthPx / arrowLengthPx;
              vx_canvas *= reduction; vy_canvas *= reduction;
            }
            const endX_canvas = startX_canvas + vx_canvas; const endY_canvas = startY_canvas + vy_canvas;
            c.beginPath(); c.moveTo(startX_canvas, startY_canvas); c.lineTo(endX_canvas, endY_canvas);
            const headAngle = Math.PI/7; const headLength = Math.min(4, arrowLengthPx * 0.35);
            const angle = Math.atan2(vy_canvas, vx_canvas);
            c.lineTo(endX_canvas - headLength * Math.cos(angle - headAngle), endY_canvas - headLength * Math.sin(angle - headAngle));
            c.moveTo(endX_canvas, endY_canvas);
            c.lineTo(endX_canvas - headLength * Math.cos(angle + headAngle), endY_canvas - headLength * Math.sin(angle + headAngle));
            c.stroke();
          }
        }
      }
    }

    function drawEducationalOverlay() {
      const f = scene.fluid; if (!f || !scene.showEduMode) return;
      const n = f.numY; const h = f.h;
      c.font = "9px Arial"; c.textAlign = "center";
      const skip = Math.max(1, Math.floor(f.numX / 12)); 
      for (let i = 0; i < f.numX; i += skip) {
        for (let j = 0; j < f.numY; j += skip) {
          const index = i * n + j;
          if (f.s[index] === 0.0) continue; 
          const x_canvas = cX((i + 0.5) * h); const y_canvas = cY((j + 0.5) * h);
          let textToDraw = "";
          if (scene.showPressure) textToDraw = `P:${f.p[index].toFixed(1)}`;
          else if (scene.showVorticity) textToDraw = `V:${f.vorticity[index].toFixed(1)}`;
          else if (scene.showVelocities) {
            const u_c = (f.u[index] + f.u[(i+1)*n+j])*0.5; const v_c = (f.v[index] + f.v[i*n+j+1])*0.5;
            textToDraw = `u:${u_c.toFixed(1)}\nv:${v_c.toFixed(1)}`;
          } else if (scene.showSmoke) textToDraw = `S:${f.m[index].toFixed(1)}`;
          if (textToDraw) {
            c.fillStyle = "rgba(255, 255, 255, 0.7)";
            const lines = textToDraw.split('\n');
            const textWidth = c.measureText(lines[0]).width; 
            c.fillRect(x_canvas - textWidth/2 - 2, y_canvas - 8 * lines.length, textWidth + 4, 10 * lines.length);
            c.fillStyle = "rgba(0, 0, 0, 0.95)";
            lines.forEach((line, lineIdx) => {
                c.fillText(line, x_canvas, y_canvas - (lines.length - 1 - lineIdx) * 10 + 6);
            });
          }
        }
      }
    }
    
    // ----- Performance Monitoring -----
    let lastTime = 0; let frameCount = 0; let fps = 0;
    const fpsUpdateInterval = 500; let lastFpsUpdate = 0;
    function updateFps(timestamp) {
      if (!lastTime) { lastTime = timestamp; lastFpsUpdate = timestamp; return; }
      frameCount++; const elapsedSinceLastUpdate = timestamp - lastFpsUpdate;
      if (elapsedSinceLastUpdate > fpsUpdateInterval) {
        fps = Math.round(frameCount * 1000 / elapsedSinceLastUpdate);
        if (fpsCounter) fpsCounter.textContent = `FPS: ${fps}`;
        frameCount = 0; lastFpsUpdate = timestamp;
      }
      lastTime = timestamp; 
    }
    
    // ----- Main Simulation Loop -----
    const MAX_SIMULATION_DT = 1.0 / 60.0; // Limit each physics step
    const CFL_NUMBER = 0.5; // Safety factor for adaptive stepping
    let lastTimestamp = 0;

    function stepSimulation(totalDt) {
      if (!scene.fluid) return;

      // Calculate a safe timestep once per frame rather than every sub-step
      const maxVel = scene.fluid.computeMaxVelocity();
      let dt = MAX_SIMULATION_DT;
      if (maxVel > 0) {
        const cflDt = CFL_NUMBER * scene.fluid.h / maxVel;
        dt = Math.min(dt, cflDt);
      }

      let accumulatedTime = 0;
      while (accumulatedTime < totalDt) {
        const stepDt = Math.min(dt, totalDt - accumulatedTime);

        if (!scene.paused) {
          if (scene.useVortices) applyVortexForces(stepDt);
          scene.fluid.simulate(stepDt, scene.gravity, scene.numIters);
          scene.frameNr++;
        }
        accumulatedTime += stepDt;
      }
    }
    function update(timestamp) {
      if (window.isResizing) {
        requestAnimationFrame(update);
        return;
      }

      if (!lastTimestamp) { // First frame initialization
          lastTimestamp = timestamp;
          requestAnimationFrame(update);
          return;
      }

      const actualDeltaTime = (timestamp - lastTimestamp) / 1000.0; // Time since last visual frame in seconds
      lastTimestamp = timestamp;

      updateFps(timestamp);

      if (audioEnabled && audioAvailable) {
        // Audio impulse might still apply based on the visual frame's sound level.
        // Consider if this should be tied to sub-steps or remain per visual frame.
        // For impulses, per-visual-frame might be fine, but forces (like vortex) need sub-steps.
        applySoundImpulse();
      }

      // Pass the actual time elapsed since the last visual frame to stepSimulation.
      // This function will then break it down into smaller, stable sub-steps.
      stepSimulation(actualDeltaTime);

      draw();
      requestAnimationFrame(update);
    //   if (window.isResizing) { requestAnimationFrame(update); return; }
    //   // const dt = (timestamp - lastTimestamp) / 1000.0; // Actual dt, if needed for variable step
    //   lastTimestamp = timestamp;
    //   updateFps(timestamp); 
    //   if (audioEnabled && audioAvailable) applySoundImpulse(); 
    //   stepSimulation(scene.dt); // Use fixed scene.dt for simulation step
    //   draw(); 
    //   requestAnimationFrame(update); 
    }
    
    // ----- Interaction Handlers -----
    let mouseIsDown = false; let currentTouchId = null; 
    function startInteraction(clientX, clientY) {
      const bounds = canvas.getBoundingClientRect();
      const mx = clientX - bounds.left; const my = clientY - bounds.top;  
      mouseIsDown = true;
      const simX = mx / cScale; const simY = (canvas.height - my) / cScale; 
      if (scene.sceneNr !== 2) { 
          setObstacle(simX, simY, true); 
      } else { // For paint mode, setObstacle is called in dragInteraction
          setObstacle(simX, simY, true); // Initial dab for paint mode
      }
    }
    function dragInteraction(clientX, clientY) {
      if (mouseIsDown) {
        const bounds = canvas.getBoundingClientRect();
        const mx = clientX - bounds.left; const my = clientY - bounds.top;
        const simX = mx / cScale; const simY = (canvas.height - my) / cScale;
        setObstacle(simX, simY, false); 
      }
    }
    function endInteraction() { 
      mouseIsDown = false; currentTouchId = null;
      if (scene.sceneNr !== 2 && scene.showObstacle) { 
         // scene.showObstacle = false; // Optionally hide mouse-drawn obstacle
      }
    }
    canvas.addEventListener('mousedown', e => { e.preventDefault(); startInteraction(e.clientX, e.clientY); });
    canvas.addEventListener('mouseup', endInteraction);
    canvas.addEventListener('mousemove', e => { dragInteraction(e.clientX, e.clientY); });
    canvas.addEventListener('mouseleave', endInteraction);
    canvas.addEventListener('touchstart', e => { e.preventDefault(); if (currentTouchId === null && e.changedTouches.length > 0) { const touch = e.changedTouches[0]; currentTouchId = touch.identifier; startInteraction(touch.clientX, touch.clientY);}}, { passive: false });
    canvas.addEventListener('touchend', e => { e.preventDefault(); for (let i = 0; i < e.changedTouches.length; i++) { if (e.changedTouches[i].identifier === currentTouchId) { endInteraction(); break; }}}, { passive: false });
    canvas.addEventListener('touchmove', e => { e.preventDefault(); for (let i = 0; i < e.changedTouches.length; i++) { const touch = e.changedTouches[i]; if (touch.identifier === currentTouchId) { dragInteraction(touch.clientX, touch.clientY); break; }}}, { passive: false });
    canvas.addEventListener('touchcancel', endInteraction);
    document.addEventListener('keydown', e => { if (e.key.toLowerCase() === 'p') { scene.paused = !scene.paused; }});
    
    // UI Control Handlers
    streamButton.addEventListener('change', function() { scene.showStreamlines = this.checked; });
    velocityButton.addEventListener('change', function() { scene.showVelocities = this.checked; });
    pressureButton.addEventListener('change', function() { scene.showPressure = this.checked; });
    smokeButton.addEventListener('change', function() { scene.showSmoke = this.checked; });
    overrelaxButton.addEventListener('change', function() { scene.overRelaxation = this.checked ? 1.9 : 1.0; });
    vorticityButton.addEventListener('change', function() { scene.showVorticity = this.checked; });
    eduModeButton.addEventListener('change', function() { scene.showEduMode = this.checked; });
    vortexButton.addEventListener('change', function() { scene.useVortices = this.checked; });
    vortexStrengthSlider.addEventListener('input', function() { scene.vortexStrength = parseFloat(this.value); });
    if (audioButton) {
        audioButton.addEventListener('change', function() {
            audioEnabled = this.checked;
            if (audioEnabled && !audioAvailable) { initAudio(); }
            if (audioIndicator) audioIndicator.style.display = audioEnabled && audioAvailable ? 'flex' : 'none';
        });
    }
    audioSensitivitySlider.addEventListener('input', function() { audioSensitivity = parseFloat(this.value) / 100.0; });
    if(micPermissionBtn) micPermissionBtn.addEventListener('click', initAudio);
    if(controlsToggle) controlsToggle.addEventListener('click', function() {
      const isVisible = controlsPanel.style.display !== 'none';
      controlsPanel.style.display = isVisible ? 'none' : 'block';
      this.textContent = isVisible ? '‚öôÔ∏è' : '√ó'; 
    });
    document.querySelectorAll('input[name="colorMap"]').forEach(radio => {
      radio.addEventListener('change', function() { if (this.checked) currentColorMap = colorMaps[this.value]; });
    });
    
    function initializeSimulation() {
        setupCanvas(); 
        updateSimDimensions();
        // Set default audio enabled state from checkbox
        if (audioButton) audioEnabled = audioButton.checked;


        setupScene(2); // Default scene

        loadingIndicator.style.display = 'flex'; 

        setTimeout(() => { 
            try {
                if (checkAudioSupport() && audioEnabled) { // Only initAudio if checkbox is initially checked
                    initAudio(); 
                } else if (!checkAudioSupport()){
                    showAudioNotAvailable();
                } else { // Audio supported but not enabled by default
                    loadingIndicator.style.display = 'none'; // Hide loading if not attempting audio
                     if (audioIndicator) audioIndicator.style.display = 'none';
                }
            } catch (error) {
                console.error("Could not initialize audio:", error);
                showAudioNotAvailable();
            } finally {
                // This finally block might hide loading too soon if initAudio is async and takes time.
                // initAudio itself handles hiding loadingIndicator on success/failure.
                if(scene.fluid) { 
                    if (!audioAvailable && !audioEnabled) loadingIndicator.style.display = 'none'; // Ensure it's hidden if audio wasn't attempted
                    lastTimestamp = performance.now(); 
                    requestAnimationFrame(update);
                } else {
                    console.error("Fluid not initialized, cannot start animation loop.");
                    loadingIndicator.innerHTML = "<p>Error initializing simulation.</p>";
                }
            }
        }, 100); 
    }

    window.addEventListener('DOMContentLoaded', (event) => {
        initializeSimulation();
    });

  </script>
</body>
</html> -->
