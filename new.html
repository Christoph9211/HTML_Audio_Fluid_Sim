<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Fluid Simulation Reacting to Sound</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: Verdana, sans-serif;
      font-size: 15px;
      margin: 0;
      overflow: hidden;
    }
    .button {
      background-color: #606060;
      border: none;
      color: white;
      padding: 10px;
      font-size: 16px;
      margin: 4px;
      cursor: pointer;
    }
    .slider {
      -webkit-appearance: none;
      appearance: none;
      width: 80px;
      height: 6px;
      border-radius: 5px;
      background: #d3d3d3;
      outline: none;
      opacity: 0.7;
      transition: opacity .2s;
    }
  </style>
</head>
<body>
  <!-- Controls (optional) -->
  <div style="position: absolute; z-index: 2; top: 10px; left: 10px;">
    <button class="button" onclick="setupScene(1)">Wind Tunnel</button>
    <button class="button" onclick="setupScene(3)">Hires Tunnel</button>
    <button class="button" onclick="setupScene(0)">Tank</button>
    <button class="button" onclick="setupScene(2)">Paint</button>
    <input type="checkbox" id="streamButton" onclick="scene.showStreamlines = !scene.showStreamlines">Streamlines
    <input type="checkbox" id="velocityButton" onclick="scene.showVelocities = !scene.showVelocities">Velocities
    <input type="checkbox" id="pressureButton" onclick="scene.showPressure = !scene.showPressure;">Pressure
    <input type="checkbox" id="smokeButton" onclick="scene.showSmoke = !scene.showSmoke;" checked>Smoke
    <input type="checkbox" id="overrelaxButton" onclick="scene.overRelaxation = scene.overRelaxation == 1.0 ? 1.9 : 1.0" checked>Overrelax
    <input type="checkbox" id="vortexButton" onclick="scene.useVortices = !scene.useVortices;" checked>Enable Vortices
    <input type="range" min="1" max="50" value="1" class="slider" id="vortexStrength" 
           oninput="scene.vortexStrength = parseInt(this.value)">
    <label for="vortexStrength">Vortex Strength</label>
  </div>
  
  <!-- Canvas for fluid simulation -->
  <canvas id="myCanvas" style="border:2px solid; display:block;"></canvas>
  
  <script>
    // ----- Audio Input Setup using Web Audio API -----
    let audioContext, analyser, dataArray;
    /**
     * Initializes audio input using the Web Audio API.
     * 
     * @promise
     * @fulfill {Analyser} analyser
     * @reject {Error} err
     */
    function initAudio() {
      navigator.mediaDevices.getUserMedia({ audio: true })
      .then(function(stream) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256; // low resolution is fine for overall level
        source.connect(analyser);
        dataArray = new Uint8Array(analyser.frequencyBinCount);
      })
      .catch(function(err) {
        console.error('Error accessing microphone: ', err);
      });
    }

    /**
     * Returns a normalized sound level between 0 and ~1 based on RMS of the timeâ€“domain data
     * 
     * @return {number} normalized sound level
     */
    function getSoundLevel() {
      if (!analyser) return 0;
      analyser.getByteTimeDomainData(dataArray);
      let sum = 0;
      for (let i = 0; i < dataArray.length; i++) {
        const sample = dataArray[i] - 128;
        sum += sample * sample;
      }
      const rms = Math.sqrt(sum / dataArray.length);
      return rms / 128;
    }

    // ----- Fluid Simulation Code (inspired by fluid_sim.html) -----
    const canvas = document.getElementById("myCanvas");
    const c = canvas.getContext("2d");	
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    canvas.focus();

    const simHeight = 1.1;	
    const cScale = canvas.height / simHeight;
    const simWidth = canvas.width / cScale;

    const U_FIELD = 0, V_FIELD = 1, S_FIELD = 2;
    let cnt = 0;
    
    function cX(x) { return x * cScale; }
    function cY(y) { return canvas.height - y * cScale; }

    // Fluid class representing the simulation state
    class Fluid {
      /**
       * Initialize a fluid simulation with the given parameters.
       * 
       * @param {number} density - The density of the fluid.
       * @param {number} numX - The number of cells in the x-direction.
       * @param {number} numY - The number of cells in the y-direction.
       * @param {number} h - The width and height of each cell.
       */
      constructor(density, numX, numY, h) {
        this.density = density;
        this.numX = numX + 2; 
        this.numY = numY + 2;
        this.numCells = this.numX * this.numY;
        this.h = h;
        this.u = new Float32Array(this.numCells);
        this.v = new Float32Array(this.numCells);
        this.newU = new Float32Array(this.numCells);
        this.newV = new Float32Array(this.numCells);
        this.p = new Float32Array(this.numCells);
        this.s = new Float32Array(this.numCells);
        this.m = new Float32Array(this.numCells);
        this.newM = new Float32Array(this.numCells);
        this.m.fill(1.0);
      }
      /**
       * Integrate the fluid simulation by one time step.
       * 
       * Applies gravity to all non-solid cells that are adjacent to a solid cell.
       * This is the main time-stepping function for the simulation.
       * 
       * @param {number} dt - The time step for the simulation, in seconds.
       * @param {number} gravity - The gravity force to apply to the fluid.
       */
      integrate(dt, gravity) {
        const n = this.numY;
        const arrayLength = this.numCells;
        for (let index = n + 1; index < arrayLength - n - 1; index++) {
          if (this.s[index] !== 0.0 && this.s[index - 1] !== 0.0)
            this.v[index] += gravity * dt;
        }
      }
      /**
       * Solve the incompressibility constraint for the fluid simulation.
       * 
       * This function iterates over all non-solid cells in the simulation and
       * applies a correction to the pressure and velocity fields to satisfy the
       * incompressibility constraint.
       * 
       * @param {number} numIters - The number of iterations to perform.
       * @param {number} dt - The time step for the simulation, in seconds.
       */
      solveIncompressibility(numIters, dt) {
        const n = this.numY;
        const cp = this.density * this.h / dt;
        for (let iter = 0; iter < numIters; iter++) {
          for (let i = 1; i < this.numX-1; i++) {
            for (let j = 1; j < this.numY-1; j++) {
              if (this.s[i*n + j] === 0.0) continue;
              const sx0 = this.s[(i-1)*n + j];
              const sx1 = this.s[(i+1)*n + j];
              const sy0 = this.s[i*n + j-1];
              const sy1 = this.s[i*n + j+1];
              const sSum = sx0 + sx1 + sy0 + sy1;
              if (sSum === 0.0) continue;
              const div = this.u[(i+1)*n + j] - this.u[i*n + j] +
                          this.v[i*n + j+1] - this.v[i*n + j];
              let pCorr = -div / sSum;
              pCorr *= scene.overRelaxation;
              this.p[i*n + j] += cp * pCorr;
              this.u[i*n + j] -= sx0 * pCorr;
              this.u[(i+1)*n + j] += sx1 * pCorr;
              this.v[i*n + j] -= sy0 * pCorr;
              this.v[i*n + j+1] += sy1 * pCorr;
            }
          }
        }
      }
      /**
       * Extrapolate the values of the velocity field to the boundaries of the
       * simulation domain.
       * 
       * This function copies the values of the velocity field from the interior
       * of the simulation domain to the boundaries.  It is used to handle
       * boundary conditions for the fluid simulation.
       */
      extrapolate() {
        const n = this.numY;
        for (let i = 0; i < this.numX; i++) {
          this.u[i*n + 0] = this.u[i*n + 1];
          this.u[i*n + this.numY-1] = this.u[i*n + this.numY-2];
        }
        for (let j = 0; j < this.numY; j++) {
          this.v[0*n + j] = this.v[1*n + j];
          this.v[(this.numX-1)*n + j] = this.v[(this.numX-2)*n + j];
        }
      }
      /**
       * Interpolate a field value at a given position.
       * 
       * @param {number} x - The x-coordinate of the position.
       * @param {number} y - The y-coordinate of the position.
       * @param {number} field - The field to sample.  This can be one of
       *                         U_FIELD, V_FIELD, or S_FIELD.
       * @return {number} The interpolated field value.
       */
      sampleField(x, y, field) {
        const n = this.numY;
        const h = this.h;
        const h1 = 1.0 / h;
        const h2 = 0.5 * h;
        x = Math.max(Math.min(x, this.numX * h), h);
        y = Math.max(Math.min(y, this.numY * h), h);
        let dx = 0, dy = 0, f;
        switch (field) {
          case U_FIELD: f = this.u; dy = h2; break;
          case V_FIELD: f = this.v; dx = h2; break;
          case S_FIELD: f = this.m; dx = h2; dy = h2; break;
        }
        const x0 = Math.min(Math.floor((x-dx)*h1), this.numX-1);
        const tx = ((x-dx) - x0*h) * h1;
        const x1 = Math.min(x0 + 1, this.numX-1);
        const y0 = Math.min(Math.floor((y-dy)*h1), this.numY-1);
        const ty = ((y-dy) - y0*h) * h1;
        const y1 = Math.min(y0 + 1, this.numY-1);
        const sx = 1.0 - tx, sy = 1.0 - ty;
        return sx*sy * f[x0*n + y0] +
               tx*sy * f[x1*n + y0] +
               tx*ty * f[x1*n + y1] +
               sx*ty * f[x0*n + y1];
      }
        /**
         * Compute the average u velocity at the given position.
         * 
         * @param {number} i - The x-coordinate of the position.
         * @param {number} j - The y-coordinate of the position.
         * @return {number} The average u velocity at the position.
         */
      avgU(i, j) {
        const n = this.numY;
        return (this.u[i*n + j-1] + this.u[i*n + j] +
                this.u[(i+1)*n + j-1] + this.u[(i+1)*n + j]) * 0.25;
      }
        /**
         * Compute the average v velocity at the given position.
         *
         * @param {number} i - The x-coordinate of the position.
         * @param {number} j - The y-coordinate of the position.
         * @return {number} The average v velocity at the position.
         */
      avgV(i, j) {
        const n = this.numY;
        return (this.v[(i-1)*n + j] + this.v[i*n + j] +
                this.v[(i-1)*n + j+1] + this.v[i*n + j+1]) * 0.25;
      }
      /**
       * Advects the velocity fields based on the current velocity and time step.
       * 
       * @param {number} dt - The time step for the simulation.
       */
      advectVel(dt) {
        this.newU.set(this.u);
        this.newV.set(this.v);
        const n = this.numY;
        const h = this.h, h2 = 0.5 * h;
        for (let i = 1; i < this.numX; i++) {
          for (let j = 1; j < this.numY; j++) {
            // u component
            if (this.s[i*n + j] !== 0.0 && this.s[(i-1)*n + j] !== 0.0 && j < this.numY - 1) {
              let x = i * h, y = j * h + h2;
              let u_val = this.u[i*n + j];
              let v_val = this.avgV(i, j);
              x = x - dt*u_val;
              y = y - dt*v_val;
              u_val = this.sampleField(x,y, U_FIELD);
              this.newU[i*n + j] = u_val;
            }
            // v component
            if (this.s[i*n + j] !== 0.0 && this.s[i*n + j-1] !== 0.0 && i < this.numX - 1) {
              let x = i * h + h2, y = j * h;
              let u_val = this.avgU(i, j);
              let v_val = this.v[i*n + j];
              x = x - dt*u_val;
              y = y - dt*v_val;
              v_val = this.sampleField(x,y, V_FIELD);
              this.newV[i*n + j] = v_val;
            }
          }
        }
        this.u.set(this.newU);
        this.v.set(this.newV);
      }
      /**
       * Advects the smoke field using a semi-Lagrangian method.
       *
       * The function computes the new positions of smoke particles
       * based on the current velocity field and time step, and updates
       * the smoke density field accordingly.
       *
       * @param {number} dt - The time step for the simulation.
       */
      advectSmoke(dt) {
        this.newM.set(this.m);
        const n = this.numY;
        const h = this.h, h2 = 0.5 * h;
        for (let i = 1; i < this.numX-1; i++) {
          for (let j = 1; j < this.numY-1; j++) {
            if (this.s[i*n + j] !== 0.0) {
              const u_val = (this.u[i*n + j] + this.u[(i+1)*n + j]) * 0.5;
              const v_val = (this.v[i*n + j] + this.v[i*n + j+1]) * 0.5;
              const x = i*h + h2 - dt*u_val;
              const y = j*h + h2 - dt*v_val;
              this.newM[i*n + j] = this.sampleField(x,y, S_FIELD);
            }
          }
        }
        this.m.set(this.newM);
      }
      /**
       * Simulates the fluid simulation for one time step.
       *
       * The function first integrates the velocity field based on the
       * external forces and gravity, then solves the incompressibility
       * constraint, extrapolates the velocity field to the boundaries,
       * and finally advects both the velocity and the smoke fields.
       *
       * @param {number} dt - The time step for the simulation.
       * @param {number} gravity - The strength of the gravity.
       * @param {number} numIters - The number of iterations to use when
       *     solving the incompressibility constraint.
       */
      simulate(dt, gravity, numIters) {
        this.integrate(dt, gravity);
        this.p.fill(0.0);
        this.solveIncompressibility(numIters, dt);
        this.extrapolate();
        this.advectVel(dt);
        this.advectSmoke(dt);
      }
    }

    // ----- Scene and Rendering -----
    const scene = {
      gravity: -9.81,
      dt: 1.0 / 60.0,
      numIters: 40,
      frameNr: 0,
      overRelaxation: 1.9,
      obstacleX: 0.0,
      obstacleY: 0.0,
      obstacleRadius: 0.1, // Updated to the new radius
      paused: false,
      sceneNr: 1,
      showObstacle: false,
      showStreamlines: false,
      showVelocities: false,
      showPressure: false,
      showSmoke: true,
      useVortices: true,
      vortexStrength: 10.0,
      fluid: null
    };

    /**
     * Sets up a new fluid simulation scene with the given scene number.
     *
     * The function initializes a new fluid simulation with the given scene number.
     * The scene number determines the initial conditions for the simulation, such as
     * the position and radius of the obstacle, the gravity, the time step, and the
     * number of iterations to use when solving the incompressibility constraint.
     *
     * @param {number} sceneNr - The scene number to set up. Defaults to 0.
     */
    function setupScene(sceneNr = 0) {
      scene.sceneNr = sceneNr;
      scene.obstacleRadius = 0.1; // Set to the updated radius
      scene.overRelaxation = 1.9;
      scene.dt = 1.0 / 60.0;
      scene.numIters = 40;
      let res = (sceneNr === 3) ? 200 : (sceneNr === 0 ? 50 : 100);
      const domainHeight = 1.0;
      const domainWidth = domainHeight / simHeight * simWidth;
      const h = domainHeight / res;
      const numX = Math.floor(domainWidth / h);
      const numY = Math.floor(domainHeight / h);
      const density = 1000.0;
      scene.fluid = new Fluid(density, numX, numY, h);
      const f = scene.fluid;
      const n = f.numY;

      // Initialize smoke density to 0 for all scenes
      for (let i = 0; i < f.numX; i++) {
        for (let j = 0; j < f.numY; j++) {
          f.m[i*n+j] = 0.0;
        }
      }
      
      if (sceneNr === 0) { // tank
        for (let i = 0; i < f.numX; i++) {
          for (let j = 0; j < f.numY; j++) {
            f.s[i*n+j] = (i === 0 || i === f.numX-1 || j === 0) ? 0.0 : 1.0;
          }
        }
        scene.gravity = -9.81;
        scene.showPressure = true;
        scene.showSmoke = false;
      } else if (sceneNr === 1 || sceneNr === 3) { // vortex shedding
        const inVel = 2.0;
        for (let i = 0; i < f.numX; i++) {
          for (let j = 0; j < f.numY; j++) {
            f.s[i*n+j] = (i === 0 || j === 0 || j === f.numY-1) ? 0.0 : 1.0;
            if (i === 1) f.u[i*n+j] = inVel;
          }
        }
        // Create a simple obstacle
        setObstacle(0.4, 0.5, true);
        scene.gravity = 0.0;
        scene.showSmoke = true;
        if (sceneNr === 3) {
          scene.dt = 1.0/60.0;
          scene.numIters = 40;
          scene.showPressure = true;
        }
      } else if (sceneNr === 2) { // paint mode
        scene.gravity = 0.0;
        scene.overRelaxation = 1.0;
        scene.showSmoke = true;
        scene.obstacleRadius = 0.1;

        // Additional settings or behavior specific to paint mode can be implemented here.
        // You might want to set some initial conditions for the fluid in paint mode.
        // For example, you could populate the fluid's density or velocity fields here.
        // for (let i = 0; i < f.numX; i++) {
        //   for (let j = 0; j < f.numY; j++) {
        //     f.m[i*n+j] = 0.0; // Initialize smoke density to 0
        //   }
        // }

        // Set initial conditions for paint mode (optional)
        for (let i = Math.floor(f.numX * 0.4); i < Math.floor(f.numX * 0.6); i++) {
          for (let j = Math.floor(f.numY * 0.4); j < Math.floor(f.numY * 0.6); j++) {
            f.m[i*n+j] = 0.0; // Add some initial smoke density
          }
        }
      }

      document.getElementById("streamButton").checked = scene.showStreamlines;
      document.getElementById("velocityButton").checked = scene.showVelocities;
      document.getElementById("pressureButton").checked = scene.showPressure;
      document.getElementById("smokeButton").checked = scene.showSmoke;
      document.getElementById("overrelaxButton").checked = scene.overRelaxation > 1.0;
      document.getElementById("vortexButton").checked = scene.useVortices;
      document.getElementById("vortexStrength").value = scene.vortexStrength;
    }

    // Add after the scene object definition
    class VortexPoint {
      constructor(x, y, strength = 1.0) {
        this.x = x;
        this.y = y;
        this.strength = strength;
        this.originalX = x;
        this.originalY = y;
      }
      
      // Add method to reset position if it moves too far
      normalizePosition() {
        if (this.x < 0.1) this.x = 0.1;
        if (this.x > 0.9) this.x = 0.9;
        if (this.y < 0.1) this.y = 0.1;
        if (this.y > 0.9) this.y = 0.9;
      }
    }

      // Initialize vortex points
      const vortexPoints = [];
      const centerX = 0.6, centerY = 0.5, radius = 0.05, numPoints = 3;
      for (let i = 0; i < numPoints; i++) {
        const angle = (i / numPoints) * 2 * Math.PI;
        const x = centerX + radius * Math.cos(angle);
        const y = centerY + radius * Math.sin(angle);
        vortexPoints.push(new VortexPoint(x, y, 0.8));
      }

      // Add to scene object
      scene.vortexPoints = vortexPoints;
      scene.vortexStrength = 1.0; // Adjustable strength
      scene.useVortices = true;  // Control flag

    function applyVortexForces() {
      if (!scene.useVortices) return;
      
      const fluid = scene.fluid;
      const n = fluid.numY;
      const h = fluid.h;
      const strength = scene.vortexStrength;
      
      // Loop through each vortex point
      for (const vortex of scene.vortexPoints) {
        // Move vortex position based on sound
        const soundLevel = getSoundLevel();
        vortex.x += (Math.random() - 0.5) * soundLevel * 0.02;
        vortex.y += (Math.random() - 0.5) * soundLevel * 0.02;
        vortex.normalizePosition();
        
        // Now apply vortex forces to the fluid
        for (let i = 1; i < fluid.numX - 1; i++) {
          for (let j = 1; j < fluid.numY - 1; j++) {
            // Skip solid cells
            if (fluid.s[i*n+j] === 0.0) continue;
            
            // Calculate distance from cell to vortex
            const cellX = (i + 0.5) * h;
            const cellY = (j + 0.5) * h;
            const dx = cellX - vortex.x;
            const dy = cellY - vortex.y;
            const distance = Math.sqrt(dx*dx + dy*dy);
            
            if (distance < 0.25) { // Only affect nearby cells
              // Calculate force direction (perpendicular to radius)
              const forceMagnitude = (0.25 - distance) * vortex.strength * strength * (soundLevel + 0.1);
              
              // Apply perpendicular force (creates rotation)
              const vx = -dy * forceMagnitude / distance;
              const vy = dx * forceMagnitude / distance;
              
              // Apply to velocity field - both u and v components
              fluid.u[i*n+j] += vx * 0.5;
              fluid.u[(i+1)*n+j] += vx * 0.5;
              fluid.v[i*n+j] += vy * 0.5;
              fluid.v[i*n+j+1] += vy * 0.5;
              
              // Optionally, inject some smoke/dye at vortex centers
              // if (distance < 0.05 && soundLevel > 0.2 && scene.sceneNr === 2) {
              //   fluid.m[i*n+j] = Math.min(fluid.m[i*n+j] + 0.2 * soundLevel, 1.0);
              // }
            }
          }
        }
      }
    }
    /**
     * Sets the position and velocity of the obstacle in the fluid simulation.
     *
     * If reset is false, the velocity of the obstacle is computed as the difference
     * between the new and old positions divided by the time step. Otherwise, the
     * velocity is set to 0.
     *
     * The function then sets the source and boundary conditions of the fluid simulation
     * based on the obstacle's position and velocity.
     *
     * @param {number} x - The new x-coordinate of the obstacle.
     * @param {number} y - The new y-coordinate of the obstacle.
     * @param {boolean} reset - Whether to reset the velocity of the obstacle to 0.
     */
    function setObstacle(x, y, reset) {
      let vx = 0.0, vy = 0.0;
      if (!reset) {
        vx = (x - scene.obstacleX) / scene.dt;
        vy = (y - scene.obstacleY) / scene.dt;
      }
      scene.obstacleX = x;
      scene.obstacleY = y;
      const r = scene.obstacleRadius;
      const f = scene.fluid;
      const n = f.numY;
      for (let i = 1; i < f.numX-2; i++) {
        for (let j = 1; j < f.numY-2; j++) {
          f.s[i*n+j] = 1.0;
          const dx = (i+0.5)*f.h - x;
          const dy = (j+0.5)*f.h - y;
          if (dx*dx+dy*dy < r*r) {
            f.s[i*n+j] = 0.0;
            f.m[i*n+j] = (scene.sceneNr === 2) ? (0.5 + 0.5*Math.sin(0.1*scene.frameNr)) : 1.0;
            f.u[i*n+j] = vx;
            f.u[(i+1)*n+j] = vx;
            f.v[i*n+j] = vy;
            f.v[i*n+j+1] = vy;
          }
        }
      }
      scene.showObstacle = true;
    }

    function setColor(r, g, b) {
      c.fillStyle = `rgb(${Math.floor(255*r)}, ${Math.floor(255*g)}, ${Math.floor(255*b)})`;
      c.strokeStyle = `rgb(${Math.floor(255*r)}, ${Math.floor(255*g)}, ${Math.floor(255*b)})`;
    }

    /**
     * Maps a scalar value to an RGB color using a scientific colormap.
     *
     * The function normalizes the input value `val` between `minVal` and `maxVal`,
     * then divides the normalized range into four segments to map it onto a color
     * gradient. The gradient transitions through blue, cyan, green, yellow, and
     * red colors. The resulting color is returned as an array of RGBA values,
     * where each channel is an integer from 0 to 255.
     *
     * @param {number} val - The scalar value to be mapped to a color.
     * @param {number} minVal - The minimum value of the scalar range.
     * @param {number} maxVal - The maximum value of the scalar range.
     * @returns {number[]} An array representing the RGBA color.
     */
    function getSciColor(val, minVal, maxVal) {
      val = Math.min(Math.max(val, minVal), maxVal-0.0001);
      const d = maxVal - minVal;
      val = d === 0.0 ? 0.5 : (val - minVal) / d;
      const m = 0.25;
      const num = Math.floor(val / m);
      const s = (val - num * m) / m;
      let r, g, b;
      switch(num) {
        case 0: r = 0.0; g = s; b = 1.0; break;
        case 1: r = 0.0; g = 1.0; b = 1.0 - s; break;
        case 2: r = s; g = 1.0; b = 0.0; break;
        case 3: r = 1.0; g = 1.0 - s; b = 0.0; break;
      }
      return [255*r, 255*g, 255*b, 255];
    }

/**
 * Renders the fluid simulation on the canvas.
 *
 * The function first clears the canvas and determines the maximum and minimum
 * pressure values in the fluid. It then loops over the fluid's cells and
 * determines the color of each cell based on its pressure value. If the
 * `showPressure` scene option is enabled, the color is determined by the
 * pressure value. If `showSmoke` is enabled, the color is determined by the
 * smoke density. If neither option is enabled, the color is black for solid
 * cells and white for fluid cells.
 *
 * The function then loops over the cells and draws a rectangle for each cell
 * with the determined color.
 *
 * Finally, if the `showVelocities` scene option is enabled, the function draws
 * velocity vectors for each cell. The length of the vectors is proportional to
 * the magnitude of the velocity.
 */
    function draw() {
      c.clearRect(0, 0, canvas.width, canvas.height);
      const f = scene.fluid;
      const n = f.numY;
      const h = f.h;
      
      // Find min/max pressure for color scaling
      let minP = f.p[0], maxP = f.p[0];
      for (let i = 0; i < f.numCells; i++) {
        minP = Math.min(minP, f.p[i]);
        maxP = Math.max(maxP, f.p[i]);
      }
      
      // Create image data for pixel manipulation
      const id = c.getImageData(0, 0, canvas.width, canvas.height);
      let color = [255, 255, 255, 255];
      
      // Calculate cell dimensions once
      const cellWidth = Math.floor(cScale * 1.1 * h) + 1;
      const cellHeight = Math.floor(cScale * 1.1 * h) + 1;
      
      // Render fluid cells
      for (let i = 0; i < f.numX; i++) {
        for (let j = 0; j < f.numY; j++) {
          const idx = i*n+j;
          
          // Determine cell color based on visualization mode
          if (scene.showPressure) {
            const p = f.p[idx];
            const sVal = f.m[idx];
            color = getSciColor(p, minP, maxP);
            
            if (scene.showSmoke) {
              // Darken color based on smoke density
              color[0] = Math.max(0, color[0] - 255*sVal);
              color[1] = Math.max(0, color[1] - 255*sVal);
              color[2] = Math.max(0, color[2] - 255*sVal);
            }
          } else if (scene.showSmoke) {
            const sVal = f.m[idx];
            color = [255*sVal, 255*sVal, 255*sVal, 255];
          } else {
            // Default: black for obstacles, white for fluid
            color = f.s[idx] === 0.0 ? [0, 0, 0, 255] : [255, 255, 255, 255];
          }
          
          // Calculate pixel coordinates
          const x = Math.floor(cX(i * h));
          const y = Math.floor(cY((j+1) * h));
          
          // Fill the cell with the calculated color
          for (let yi = y; yi < y + cellHeight; yi++) {
            if (yi < 0 || yi >= canvas.height) continue; // Skip out-of-bounds rows
            
            let pIdx = 4 * (yi * canvas.width + x);
            
            // Fast path for filling a row of pixels
            for (let xi = 0; xi < cellWidth; xi++) {
              if (x + xi >= canvas.width) break; // Skip out-of-bounds columns
              
              id.data[pIdx++] = color[0];
              id.data[pIdx++] = color[1];
              id.data[pIdx++] = color[2];
              id.data[pIdx++] = 255;
            }
          }
        }
      }
      
      // Apply the pixel data to the canvas
      c.putImageData(id, 0, 0);

      // Draw vortex points if enabled
      if (!scene.useVortices) {
        c.lineWidth = 2;
        const soundLevel = getSoundLevel();
        
        for (const vortex of scene.vortexPoints) {
          const x = cX(vortex.x);
          const y = cY(vortex.y);
          
          // Calculate vortex intensity based on sound level
          const intensity = Math.min(0.2 + soundLevel * 3, 1.0);
          
          // Draw vortex circle
          c.beginPath();
          c.arc(x, y, 10, 0, Math.PI * 2);
          c.strokeStyle = `rgba(255, 255, 0, ${intensity})`;
          c.stroke();
          
          // Draw swirl lines
          c.beginPath();
          const radius = 15;
          for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
            c.moveTo(x, y);
            c.lineTo(
              x + radius * Math.cos(angle), 
              y + radius * Math.sin(angle)
            );
          }
          c.strokeStyle = `rgba(255, 200, 0, ${intensity * 0.7})`;
          c.stroke();
        }
      }

      // Draw velocity vectors if enabled
      if (scene.showVelocities) {
        c.strokeStyle = "#000";
        const scale = 0.02;
        
        for (let i = 0; i < f.numX; i++) {
          for (let j = 0; j < f.numY; j++) {
            const idx = i*n+j;
            
            // Draw horizontal velocity component (u)
            const u_val = f.u[idx];
            if (Math.abs(u_val) > 0.01) {  // Only draw significant velocities
              const x0 = cX(i*h);
              const y0 = cY((j+0.5)*h);
              c.beginPath();
              c.moveTo(x0, y0);
              c.lineTo(cX(i*h + u_val*scale), y0);
              c.stroke();
            }
            
            // Draw vertical velocity component (v)
            const v_val = f.v[idx];
            if (Math.abs(v_val) > 0.01) {  // Only draw significant velocities
              const x = cX((i+0.5)*h);
              const y_start = cY(j*h);
              c.beginPath();
              c.moveTo(x, y_start);
              c.lineTo(x, cY(j*h + v_val*scale));
              c.stroke();
            }
          }
        }
      }
    }

    // ----- Microphone-based Fluid Disturbance -----
    // Apply a random velocity impulse in a small block around the center of the simulation
    // when the sound level exceeds a small threshold.
    function applySoundImpulse() {
      const soundLevel = getSoundLevel();
      if (soundLevel > 0.01) {
        const fluid = scene.fluid;
        const centerX = Math.floor(fluid.numX / 2);
        const centerY = Math.floor(fluid.numY / 2);
        const impulseStrength = soundLevel * 100.0;
        for (let i = -1; i <= 1; i++) {
          for (let j = -1; j <= 1; j++) {
            const index = (centerX + i) * fluid.numY + (centerY + j);
            if (index >= 0 && index < fluid.numCells) {
              fluid.u[index] += impulseStrength * (Math.random() + 0.5);
              fluid.v[index] += impulseStrength * (Math.random() + 0.5);
            }
          }
        }
      }
    }

    // ----- Main Simulation Loop -----
    function simulate() {
      if (!scene.paused) {
        applyVortexForces(); // Apply vortex forces before the simulation step
        scene.fluid.simulate(scene.dt, scene.gravity, scene.numIters);
        scene.frameNr++;
      }
    }
    
    /**
     * Main simulation loop.
     * 
     * Applies a random velocity impulse in a small block around the center of the simulation
     * when the sound level exceeds a small threshold, then runs a simulation step, then
     * renders the updated simulation state, and finally requests the next animation frame.
     */
    function update() {
      applySoundImpulse(); // add audio-reactive disturbance each frame
      simulate();
      draw();
      requestAnimationFrame(update);
    }

    // ----- Interaction Handlers -----
    let mouseDown = false;
      /**
      * Initiates dragging operation for setting an obstacle in the fluid simulation.
      * 
      * This function is triggered when a mouse or touch event starts. It calculates
      * the relative position of the event on the canvas, updates the global position
      * accordingly, and sets the flag for dragging. It then places an obstacle at
      * the computed position with reset velocity.
      * 
      * @param {number} x - The x-coordinate of the event.
      * @param {number} y - The y-coordinate of the event.
      */
    function startDrag(x, y) {
      const bounds = canvas.getBoundingClientRect();
      let mx = x - bounds.left;
      let my = y - bounds.top;
      mouseDown = true;
      x = mx / cScale;
      y = (canvas.height - my) / cScale;
      setObstacle(x, y, true);
    }
    /**
     * Continues a dragging operation for setting an obstacle in the fluid simulation.
     * 
     * This function is triggered on mouse or touch events while the dragging flag is
     * set. It calculates the relative position of the event on the canvas, updates
     * the global position accordingly, and sets the flag for dragging. It then moves
     * the obstacle to the computed position without resetting the velocity.
     * 
     * @param {number} x - The x-coordinate of the event.
     * @param {number} y - The y-coordinate of the event.
     */
    function drag(x, y) {
      if (mouseDown) {
        const bounds = canvas.getBoundingClientRect();
        let mx = x - bounds.left;
        let my = y - bounds.top;
        x = mx / cScale;
        y = (canvas.height - my) / cScale;
        setObstacle(x, y, false);
      }
    }
    function endDrag() { mouseDown = false; }
    canvas.addEventListener('mousedown', e => startDrag(e.x, e.y));
    canvas.addEventListener('mouseup', endDrag);
    canvas.addEventListener('mousemove', e => drag(e.x, e.y));
    canvas.addEventListener('touchstart', e => startDrag(e.touches[0].clientX, e.touches[0].clientY));
    canvas.addEventListener('touchend', endDrag);
    canvas.addEventListener('touchmove', e => { e.preventDefault(); drag(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
    document.addEventListener('keydown', e => { if (e.key === 'p') scene.paused = !scene.paused; });
    
    // ----- Start Everything -----
    setupScene(2);
    initAudio(); // initialize microphone input
    update();
  </script>
</body>
</html>
